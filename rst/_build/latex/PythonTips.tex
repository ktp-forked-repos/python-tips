% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[a4paper,12pt,oneside]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}
\usepackage{mathpazo}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}
\usepackage{flaskstyle}

\title{Python Tips}
\date{April 28, 2015}
\release{0.1}
\author{Muhammad Yasoob Ullah Khalid}
\newcommand{\sphinxlogo}{\includegraphics{logo-full.png}\par}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}



\part{Author}
\label{index:python-tips}\label{index:author}
I am Muhammad Yasoob Ullah Khalid. I have been programming extensively in Python for over 3 years now. I have been involved in a lot of Open Source projects. I regularly blog about interesting Python topics over at my \href{http://www.freepythontips.wordpress.com}{blog} . In 2014 I also presented at EuroPython which was held in Berlin. It is the biggest Python conference in Europe.


\part{Preface}
\label{index:preface}
Python is an amazing language with a strong and friendly community of programmers. However, not all of them are familiar with the tips and patterns of this language. It is easy for the beginners to overlook them and most books do not mention these tips and patterns. In this book I aim to compile most of these tips, tricks and patterns. This way every Python programmer will have easy access to them.

These tricks not only make your code more Pythonic but also reduce the amount of effort required to maintain it. This book is an outcome of my desire to have something like it when I was beginning to learn Python.

If you are a beginner, intermediate or even an advanced programmer there is something for you in this book.

Please note that this book is not a tutorial and does not teach you Python. Instead it teaches you how to write beautiful Python. I am sure you are as excited as I am so let's start!


\chapter{*args and **kwargs}
\label{args_and_kwargs:args-and-kwargs}\label{args_and_kwargs::doc}
I have come to see that most new python programmers have a hard time
figuring out the *args and **kwargs magic variables. So what are they
? First of all let me tell you that it is not necessary to write *args
or **kwargs. Only the \code{*} (aesteric) is necessary. You could have
also written *var and **vars. Writing *args and **kwargs is just a
convention. So now lets take a look at *args first.


\section{Usage of *args}
\label{args_and_kwargs:usage-of-args}
*args and **kwargs are mostly used in function definitions. *args
and **kwargs allow you to pass a variable number of arguments to a
function. What does variable mean here is that you do not know before
hand that how many arguments can be passed to your function by the user
so in this case you use these two keywords. *args is used to send a
\textbf{non-keyworded} variable length argument list to the function. Here's
an example to help you get a clear idea:
\DUspan{keyword}{}\DUspan{name,function}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{keyword}{}\DUspan{name}{}\DUspan{operator,word}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{test\PYGZus{}var\PYGZus{}args}\PYG{p}{(}\PYG{n}{f\PYGZus{}arg}\PYG{p}{,} \PYG{o}{*}\PYG{n}{argv}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{first normal arg:}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{f\PYGZus{}arg}
    \PYG{k}{for} \PYG{n}{arg} \PYG{o+ow}{in} \PYG{n}{argv}\PYG{p}{:}
        \PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{another arg through *argv :}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{arg}

\PYG{n}{test\PYGZus{}var\PYGZus{}args}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{yasoob}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{python}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{eggs}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{test}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

This produces the following result:
\DUspan{name}{}\DUspan{name}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{name}{}\DUspan{name}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{name}{}\DUspan{name}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{name}{}\DUspan{name}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}
\begin{Verbatim}[commandchars=\\\{\}]
first normal arg: yasoob
another arg through *argv : python
another arg through *argv : eggs
another arg through *argv : test
\end{Verbatim}

I hope this cleared away any confusion that you had. So now lets talk
about **kwargs


\section{Usage of **kwargs}
\label{args_and_kwargs:usage-of-kwargs}
**kwargs allows you to pass \textbf{keyworded} variable length of arguments
to a function. You should use **kwargs if you want to handle \textbf{named
arguments} in a function. Here is an example to get you going with it:
\DUspan{keyword}{}\DUspan{name,function}{}\DUspan{punctuation}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{name}{}\DUspan{operator,word}{}\DUspan{operator,word}{}\DUspan{name,builtin,pseudo}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator,word}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{literal,string}{}\DUspan{literal,string,interpol}{}\DUspan{literal,string}{}\DUspan{literal,string,interpol}{}\DUspan{literal,string}{}\DUspan{operator}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}
\begin{Verbatim}[commandchars=\\\{\}]
def greet\_me(**kwargs):
    if kwargs is not None:
        for key, value in kwargs.iteritems():
            print "\%s == \%s" \%(key,value)

\textgreater{}\textgreater{}\textgreater{} greet\_me(name="yasoob")
name == yasoob
\end{Verbatim}

So can you see how we handled a keyworded argument list in our function.
This is just the basics of **kwargs and you can see how useful it is.
Now lets talk about how you can use *args and **kwargs to call a
function with a list or dictionary of arguments.

\textbf{Using *args and **kwargs to call a function}

So here we will see how to call a function using *args and **kwargs.
Just consider that you have this little function:
\DUspan{keyword}{}\DUspan{name,function}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{keyword}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{keyword}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{name}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{test\PYGZus{}args\PYGZus{}kwargs}\PYG{p}{(}\PYG{n}{arg1}\PYG{p}{,} \PYG{n}{arg2}\PYG{p}{,} \PYG{n}{arg3}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{arg1:}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{arg1}
    \PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{arg2:}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{arg2}
    \PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{arg3:}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{arg3}
\end{Verbatim}

Now you can use *args or **kwargs to pass arguments to this little
function. Here's how to do it:
\DUspan{comment}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{literal,number,integer}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{literal,number,integer}{}\DUspan{comment}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{literal,number,integer}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{literal,number,integer}{}
\begin{Verbatim}[commandchars=\\\{\}]
\# first with *args
\textgreater{}\textgreater{}\textgreater{} args = ("two", 3,5)
\textgreater{}\textgreater{}\textgreater{} test\_args\_kwargs(*args)
arg1: two
arg2: 3
arg3: 5

\# now with **kwargs:
\textgreater{}\textgreater{}\textgreater{} kwargs = \PYGZob{}"arg3": 3, "arg2": "two","arg1":5\PYGZcb{}
\textgreater{}\textgreater{}\textgreater{} test\_args\_kwargs(**kwargs)
arg1: 5
arg2: two
arg3: 3
\end{Verbatim}

\textbf{Order of using *args **kwargs and formal args}

So if you want to use all three of these in functions then the order is
\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{some\PYGZus{}func}\PYG{p}{(}\PYG{n}{fargs}\PYG{p}{,}\PYG{o}{*}\PYG{n}{args}\PYG{p}{,}\PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}
\end{Verbatim}


\chapter{Debugging}
\label{debugging:debugging}\label{debugging::doc}
Debuggin is also something which once mastered can greatly enhance your
bug hunting skills. Most of the newcommers neglect the importance of the
Python debugger (\code{pdb}). In this section I am going to tell you only a
few important commands. You can learn more about it from the official
documentation.


\section{Using \texttt{pdb}}
\label{debugging:using-pdb}
\textbf{Running from commandline}

You can run a script from the commandline using the Python debugger.
Here is an example:
\DUspan{error}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{name}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}
\begin{Verbatim}[commandchars=\\\{\}]
\$ python -m pdb my\_script.py
\end{Verbatim}

It would cause the debugger to stop the execution on the first statement
it finds. This is helpful if you script is short. You can then inspect
the variables and continue execution line-by-line.

\textbf{Running from inside a script}

You can set break points in the script itself so that you can inspect
the variables and stuff at particular points. This is possible using the
\code{pdb.set\_trace()} method. Here is an example:
\DUspan{keyword,namespace}{}\DUspan{name,namespace}{}\DUspan{keyword}{}\DUspan{name,function}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{literal,string}{}\DUspan{keyword}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{pdb}

\PYG{k}{def} \PYG{n+nf}{make\PYGZus{}bread}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{pdb}\PYG{o}{.}\PYG{n}{set\PYGZus{}trace}\PYG{p}{(}\PYG{p}{)}
    \PYG{k}{return} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{I don}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{t have time}\PYG{l+s}{\PYGZdq{}}

\PYG{k}{print}\PYG{p}{(}\PYG{n}{make\PYGZus{}bread}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

Try running the above script after saving it. You would enter the
debugger as soon as you run it. Now it's time to learn some of the
commands of the debugger.


\section{Commands:}
\label{debugging:commands}\begin{itemize}
\item {} 
\code{c}: continue execution

\item {} 
\code{w}: shows the context of the current line it is executing.

\item {} 
\code{a}: print the argument list of the current function

\item {} 
\code{s}: Execute the current line and stop at the first possible
occasion.

\item {} 
\code{n}: Continue execution until the next line in the current function
is reached or it returns.

\end{itemize}

The difference between \code{n}ext and \code{s}tep is that step stops
inside a called function, while next executes called functions at
(nearly) full speed, only stopping at the next line in the current
function.

These are just a few commands. \code{pdb} also supports post mortem. It is
also a really handy function. I would highly suggest you to look at the
official documentation and learn more about it.


\chapter{Generators}
\label{generators:generators}\label{generators::doc}
Generators are iterators, but you can only iterate over them once. It’s
because they do not store all the values in memory, they generate the
values on the fly. You use them by iterating over them, either
explicitly with `for' or implicitly by passing it to any function or
construct that iterates. Most of the time \code{generators} are implemented
as functions. However, they do not \code{return} a value, they \code{yield}
it. Here is a simple example of a \code{generator} function:
\DUspan{keyword}{}\DUspan{name,function}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{literal,number,integer}{}\DUspan{keyword}{}\DUspan{literal,number,integer}{}\DUspan{keyword}{}\DUspan{literal,number,integer}{}\DUspan{keyword}{}\DUspan{name}{}\DUspan{operator,word}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{comment}{}\DUspan{comment}{}\DUspan{comment}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{generator\PYGZus{}function}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{yield} \PYG{l+m+mi}{1}
    \PYG{k}{yield} \PYG{l+m+mi}{2}
    \PYG{k}{yield} \PYG{l+m+mi}{3}

\PYG{k}{for} \PYG{n}{item} \PYG{o+ow}{in} \PYG{n}{generator\PYGZus{}function}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{print}\PYG{p}{(}\PYG{n}{item}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Output: 1}
\PYG{c}{\PYGZsh{} 2}
\PYG{c}{\PYGZsh{} 3}
\end{Verbatim}

It is not really useful in this case. Generators are best for
calculating large sets of results (particularly calculations involving
loops themselves) where you don't want to allocate the memory for all
results at the same time. Python modified a lot of Python 2 functions
which returned \code{lists} to return \code{generators} in Python 3. It is
because \code{generators} are not resource intensive. Here is an example
which calculates fibonacci numbers:
\DUspan{comment}{}\DUspan{keyword}{}\DUspan{name,function}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{literal,number,integer}{}\DUspan{keyword}{}\DUspan{name}{}\DUspan{operator,word}{}\DUspan{name,builtin}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{name}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} generator version}
\PYG{k}{def} \PYG{n+nf}{fibon}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{a} \PYG{o}{=} \PYG{n}{b} \PYG{o}{=} \PYG{l+m+mi}{1}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{yield} \PYG{n}{a}
        \PYG{n}{a}\PYG{p}{,} \PYG{n}{b} \PYG{o}{=} \PYG{n}{b}\PYG{p}{,} \PYG{n}{a} \PYG{o}{+} \PYG{n}{b}
\end{Verbatim}

Now we can use it like this:
\DUspan{keyword}{}\DUspan{name}{}\DUspan{operator,word}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{n}{x} \PYG{o+ow}{in} \PYG{n}{fibon}\PYG{p}{(}\PYG{l+m+mi}{1000000}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{print}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
\end{Verbatim}

This way we would not have to worry about it using a lot of resources.
However, if we would have implemented it like this:
\DUspan{keyword}{}\DUspan{name,function}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{literal,number,integer}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{name}{}\DUspan{operator,word}{}\DUspan{name,builtin}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{keyword}{}\DUspan{name}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{fibon}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{a} \PYG{o}{=} \PYG{n}{b} \PYG{o}{=} \PYG{l+m+mi}{1}
    \PYG{n}{result} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{result}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
        \PYG{n}{a}\PYG{p}{,} \PYG{n}{b} \PYG{o}{=} \PYG{n}{b}\PYG{p}{,} \PYG{n}{a} \PYG{o}{+} \PYG{n}{b}
    \PYG{k}{return} \PYG{n}{result}
\end{Verbatim}

It would have used up all our resources while calculating a large input.
Make sure that you follow this pattern and use \code{generators} whenever
they make sense. You wont be disappointed!


\chapter{Map \& Filter}
\label{map___filter:map-filter}\label{map___filter::doc}
These are two functions which facilitate a functional approach to
programming. We will discuss them one by one and understand their use
cases.


\section{1. Map}
\label{map___filter:map}
\code{Map} applies a function to all the items in an input\_list. Here is
the blueprint:

\textbf{Blueprint}
\DUspan{name,builtin}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nb}{map}\PYG{p}{(}\PYG{n}{functions\PYGZus{}to\PYGZus{}apply}\PYG{p}{,} \PYG{n}{list\PYGZus{}of\PYGZus{}inputs}\PYG{p}{)}
\end{Verbatim}

Most of the times we want to pass all the list elements to a function
one-by-one and then collect the output. For instance:
\DUspan{name}{}\DUspan{operator}{}\DUspan{punctuation}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{name}{}\DUspan{operator,word}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{items} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{]}
\PYG{n}{squared} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{items}\PYG{p}{:}
    \PYG{n}{squared}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{i}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}
\end{Verbatim}

\code{Map} allows us to implement this in a much simpler and nicer way.
Here you go:
\DUspan{name}{}\DUspan{operator}{}\DUspan{punctuation}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name,builtin}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{items} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{]}
\PYG{n}{squared} \PYG{o}{=} \PYG{n+nb}{map}\PYG{p}{(}\PYG{k}{lambda} \PYG{n}{x}\PYG{p}{:} \PYG{n}{x}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{items}\PYG{p}{)}
\end{Verbatim}

Most of the times we use lambdas with \code{map} so I did the same. Instead
of a list of inputs we can even have a list of functions!
\DUspan{keyword}{}\DUspan{name,function}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{name,function}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{name}{}\DUspan{operator,word}{}\DUspan{name,builtin}{}\DUspan{punctuation}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name,builtin}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{comment}{}\DUspan{comment}{}\DUspan{comment}{}\DUspan{comment}{}\DUspan{comment}{}\DUspan{comment}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{multiply}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{p}{(}\PYG{n}{x}\PYG{o}{*}\PYG{n}{x}\PYG{p}{)}
\PYG{k}{def} \PYG{n+nf}{add}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{p}{(}\PYG{n}{x}\PYG{o}{+}\PYG{n}{x}\PYG{p}{)}

\PYG{n}{funcs} \PYG{o}{=} \PYG{p}{[}\PYG{n}{multiply}\PYG{p}{,} \PYG{n}{add}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{value} \PYG{o}{=} \PYG{n+nb}{map}\PYG{p}{(}\PYG{k}{lambda} \PYG{n}{x}\PYG{p}{:} \PYG{n}{x}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{,} \PYG{n}{funcs}\PYG{p}{)}
    \PYG{k}{print}\PYG{p}{(}\PYG{n}{value}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Output:}
\PYG{c}{\PYGZsh{} [0, 0]}
\PYG{c}{\PYGZsh{} [1, 2]}
\PYG{c}{\PYGZsh{} [4, 4]}
\PYG{c}{\PYGZsh{} [9, 6]}
\PYG{c}{\PYGZsh{} [16, 8]}
\end{Verbatim}


\section{2. Filter}
\label{map___filter:filter}
As the name suggests, filter creats a list of elements for which a
function returns true. Here is a short and consise example:
\DUspan{name}{}\DUspan{operator}{}\DUspan{name,builtin}{}\DUspan{punctuation}{}\DUspan{operator}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name,builtin}{}\DUspan{punctuation}{}\DUspan{name,builtin}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{comment}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{number\PYGZus{}list} \PYG{o}{=} \PYG{n+nb}{range}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{n}{less\PYGZus{}than\PYGZus{}zero} \PYG{o}{=} \PYG{n+nb}{list}\PYG{p}{(}\PYG{n+nb}{filter}\PYG{p}{(}\PYG{k}{lambda} \PYG{n}{x}\PYG{p}{:} \PYG{n}{x}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{number\PYGZus{}list}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{print}\PYG{p}{(}\PYG{n}{less\PYGZus{}than\PYGZus{}zero}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Output: [\PYGZhy{}5, \PYGZhy{}4, \PYGZhy{}3, \PYGZhy{}2, \PYGZhy{}1]}
\end{Verbatim}

The filter resembles a for loop but it is a builtin function and faster.

\textbf{Note:} If map \& filter do not appear beautiful to you then you can
read about \code{list/dict/tuple} comprehensions.


\chapter{\texttt{set} Data Structure}
\label{set_-_data_structure::doc}\label{set_-_data_structure:set-data-structure}

\section{Intro to \texttt{set}}
\label{set_-_data_structure:intro-to-set}
\code{set} is a really useful data structure. \code{sets} behave mostly like
lists with the distinction that they can not contain duplicate values.
It is really useful in a lot of cases. For instance you might want to
check whether there are duplicates in a list or not. You have two
options. The first one involves using a \code{for} loop. Something like
this:
\DUspan{name}{}\DUspan{operator}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{name}{}\DUspan{operator,word}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{operator}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{name}{}\DUspan{operator,word}{}\DUspan{operator,word}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{comment}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{some\PYGZus{}list} \PYG{o}{=} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{a}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{b}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{c}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{b}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{d}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{m}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{n}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{n}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}

\PYG{n}{duplicates} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{value} \PYG{o+ow}{in} \PYG{n}{some\PYGZus{}list}\PYG{p}{:}
    \PYG{k}{if} \PYG{n}{some\PYGZus{}list}\PYG{o}{.}\PYG{n}{count}\PYG{p}{(}\PYG{n}{value}\PYG{p}{)} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{1}\PYG{p}{:}
        \PYG{k}{if} \PYG{n}{value} \PYG{o+ow}{not} \PYG{o+ow}{in} \PYG{n}{duplicates}\PYG{p}{:}
            \PYG{n}{duplicates}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{value}\PYG{p}{)}

\PYG{k}{print}\PYG{p}{(}\PYG{n}{duplicates}\PYG{p}{)}
\PYG{c}{\PYGZsh{} Output: [\PYGZsq{}b\PYGZsq{}, \PYGZsq{}n\PYGZsq{}]}
\end{Verbatim}

But there is a simpler and more elegant solution involving \code{sets}. You
can simply do something like this:
\DUspan{name}{}\DUspan{operator}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name,builtin}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{keyword}{}\DUspan{name}{}\DUspan{operator,word}{}\DUspan{name}{}\DUspan{keyword}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{operator}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{comment}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{some\PYGZus{}list} \PYG{o}{=} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{a}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{b}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{c}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{b}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{d}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{m}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{n}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{n}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{duplicates} \PYG{o}{=} \PYG{n+nb}{set}\PYG{p}{(}\PYG{p}{[}\PYG{n}{x} \PYG{k}{for} \PYG{n}{x} \PYG{o+ow}{in} \PYG{n}{some\PYGZus{}list} \PYG{k}{if} \PYG{n}{some\PYGZus{}list}\PYG{o}{.}\PYG{n}{count}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{k}{print}\PYG{p}{(}\PYG{n}{duplicates}\PYG{p}{)}
\PYG{c}{\PYGZsh{} Output: set([\PYGZsq{}b\PYGZsq{}, \PYGZsq{}n\PYGZsq{}])}
\end{Verbatim}

Sets also have a few other methods. Below are some of them.


\section{\texttt{set} Methods}
\label{set_-_data_structure:set-methods}
\textbf{Intersection}

You can intersect two sets. For instance:
\DUspan{name}{}\DUspan{operator}{}\DUspan{name,builtin}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{name,builtin}{}\DUspan{operator}{}\DUspan{name,builtin}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{punctuation}{}\DUspan{name,builtin}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{comment}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{valid} \PYG{o}{=} \PYG{n+nb}{set}\PYG{p}{(}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{yellow}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{red}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{blue}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{green}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{black}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{n+nb}{input} \PYG{o}{=} \PYG{n+nb}{set}\PYG{p}{(}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{red}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{brown}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{k}{print}\PYG{p}{(}\PYG{n+nb}{input}\PYG{o}{.}\PYG{n}{intersection}\PYG{p}{(}\PYG{n}{valid}\PYG{p}{)}\PYG{p}{)}
\PYG{c}{\PYGZsh{} Output: set([\PYGZsq{}red\PYGZsq{}])}
\end{Verbatim}

\textbf{Difference}

You can find the invalid values in the above example using the
difference method. For example:
\DUspan{name}{}\DUspan{operator}{}\DUspan{name,builtin}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{name,builtin}{}\DUspan{operator}{}\DUspan{name,builtin}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{punctuation}{}\DUspan{name,builtin}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{comment}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{valid} \PYG{o}{=} \PYG{n+nb}{set}\PYG{p}{(}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{yellow}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{red}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{blue}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{green}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{black}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{n+nb}{input} \PYG{o}{=} \PYG{n+nb}{set}\PYG{p}{(}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{red}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{brown}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{k}{print}\PYG{p}{(}\PYG{n+nb}{input}\PYG{o}{.}\PYG{n}{difference}\PYG{p}{(}\PYG{n}{valid}\PYG{p}{)}\PYG{p}{)}
\PYG{c}{\PYGZsh{} Output: set([\PYGZsq{}brown\PYGZsq{}])}
\end{Verbatim}

You can also create sets using the new notation:
\DUspan{name}{}\DUspan{operator}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{punctuation}{}\DUspan{name,builtin}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{comment}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{a\PYGZus{}set} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{red}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{blue}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{green}\PYG{l+s}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}
\PYG{k}{print}\PYG{p}{(}\PYG{n+nb}{type}\PYG{p}{(}\PYG{n}{a\PYGZus{}set}\PYG{p}{)}\PYG{p}{)}
\PYG{c}{\PYGZsh{} Output: \PYGZlt{}type \PYGZsq{}set\PYGZsq{}\PYGZgt{}}
\end{Verbatim}

There are a few other methods as well. I would recommend visiting the
official documentation and giving it a quick read.


\chapter{Ternary Operators}
\label{ternary_operators:ternary-operators}\label{ternary_operators::doc}
Ternary operators are more commonly known as conditional expressions in
Python. These operators evaluate something based on a condition being
true or not. They became a part of Python in version 2.4

Here is a blueprint and an example of using these conditional
expressions.

\textbf{Blueprint:}
\DUspan{name}{}\DUspan{keyword}{}\DUspan{name}{}\DUspan{keyword}{}\DUspan{name}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{condition\PYGZus{}is\PYGZus{}true} \PYG{k}{if} \PYG{n}{condition\PYGZus{}true} \PYG{k}{else} \PYG{n}{condition\PYGZus{}is\PYGZus{}false}
\end{Verbatim}

\textbf{Example:}
\DUspan{name}{}\DUspan{operator}{}\DUspan{name,builtin,pseudo}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{literal,string}{}\DUspan{keyword}{}\DUspan{name}{}\DUspan{keyword}{}\DUspan{literal,string}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{is\PYGZus{}fat} \PYG{o}{=} \PYG{n+nb+bp}{True}
\PYG{n}{state} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{fat}\PYG{l+s}{\PYGZdq{}} \PYG{k}{if} \PYG{n}{is\PYGZus{}fat} \PYG{k}{else} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{not fat}\PYG{l+s}{\PYGZdq{}}
\end{Verbatim}

It allows to quickly test a condition instead of a multiline if
statement. Often times it can be immensely helpful and can make your
code compact but still maintainable.

Another more obscure and not widely used example involves tuples. Here
is some sample code:

\textbf{Blueprint:}
\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{if\PYGZus{}test\PYGZus{}is\PYGZus{}false}\PYG{p}{,} \PYG{n}{if\PYGZus{}test\PYGZus{}is\PYGZus{}true}\PYG{p}{)}\PYG{p}{[}\PYG{n}{test}\PYG{p}{]}
\end{Verbatim}

\textbf{Example:}
\DUspan{name}{}\DUspan{operator}{}\DUspan{name,builtin,pseudo}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{comment}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{fat} \PYG{o}{=} \PYG{n+nb+bp}{True}
\PYG{n}{fitness} \PYG{o}{=} \PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{skinny}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{fat}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{[}\PYG{n}{fat}\PYG{p}{]}
\PYG{k}{print}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Ali is }\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{fitness}\PYG{p}{)}
\PYG{c}{\PYGZsh{} Output: Ali is fat}
\end{Verbatim}

The above example is not widely used and is generally disliked by
Pythonistas for not being Pythonic. It is also easy to confuse where to
put the true value and where to put the false value in the tuple.


\chapter{Decorators}
\label{decorators:decorators}\label{decorators::doc}
Decorators are a significant part of Python. In simple words they are
functions which modify the functionality of another function. They help
to make our code shorter and more Pythonic. Most of the beginners do not
know where to use them so I am going to share some areas where
decorators can make your code consise.

\textbf{Blueprint :}
\DUspan{keyword,namespace}{}\DUspan{name,namespace}{}\DUspan{keyword,namespace}{}\DUspan{name}{}\DUspan{keyword}{}\DUspan{name,function}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name,decorator}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{name,function}{}\DUspan{punctuation}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{operator,word}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{literal,string}{}\DUspan{keyword}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{name}{}\DUspan{name,decorator}{}\DUspan{keyword}{}\DUspan{name,function}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{literal,string}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name,builtin,pseudo}{}\DUspan{keyword}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{comment}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name,builtin,pseudo}{}\DUspan{keyword}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{comment}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{functools} \PYG{k+kn}{import} \PYG{n}{wraps}
\PYG{k}{def} \PYG{n+nf}{decorator\PYGZus{}name}\PYG{p}{(}\PYG{n}{f}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nd}{@wraps}\PYG{p}{(}\PYG{n}{f}\PYG{p}{)}
    \PYG{k}{def} \PYG{n+nf}{decorated}\PYG{p}{(}\PYG{o}{*}\PYG{n}{args}\PYG{p}{,} \PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{if} \PYG{o+ow}{not} \PYG{n}{can\PYGZus{}run}\PYG{p}{:}
            \PYG{k}{return} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Function will not run}\PYG{l+s}{\PYGZdq{}}
        \PYG{k}{return} \PYG{n}{f}\PYG{p}{(}\PYG{o}{*}\PYG{n}{args}\PYG{p}{,} \PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{decorated}

\PYG{n+nd}{@decorator\PYGZus{}name}
\PYG{k}{def} \PYG{n+nf}{func}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Function is running}\PYG{l+s}{\PYGZdq{}}

\PYG{n}{can\PYGZus{}run} \PYG{o}{=} \PYG{n+nb+bp}{True}
\PYG{k}{print}\PYG{p}{(}\PYG{n}{func}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{c}{\PYGZsh{} Output: Function is running}

\PYG{n}{can\PYGZus{}run}\PYG{o}{=}\PYG{n+nb+bp}{False}
\PYG{k}{print}\PYG{p}{(}\PYG{n}{func}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{c}{\PYGZsh{} Output: Function will not run}
\end{Verbatim}

Note: \code{@wraps} takes a function to be decorated and adds the
functionality of copying over the function name, docstring, arguments
list, etc. This allows to access the pre-decorated function's properties
in the decorator.


\section{Authorization}
\label{decorators:authorization}
Decorators can help to check whether someone is authorized to use an
endpoint in a web application. They are extensively used in Flask web
framework and Django. Here is an example to employ decorator based
authentication:

\textbf{Example :}
\DUspan{keyword,namespace}{}\DUspan{name,namespace}{}\DUspan{keyword,namespace}{}\DUspan{name}{}\DUspan{keyword}{}\DUspan{name,function}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name,decorator}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{name,function}{}\DUspan{punctuation}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{keyword}{}\DUspan{operator,word}{}\DUspan{name}{}\DUspan{operator,word}{}\DUspan{operator,word}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{name}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{functools} \PYG{k+kn}{import} \PYG{n}{wraps}

\PYG{k}{def} \PYG{n+nf}{requires\PYGZus{}auth}\PYG{p}{(}\PYG{n}{f}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nd}{@wraps}\PYG{p}{(}\PYG{n}{f}\PYG{p}{)}
    \PYG{k}{def} \PYG{n+nf}{decorated}\PYG{p}{(}\PYG{o}{*}\PYG{n}{args}\PYG{p}{,} \PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{auth} \PYG{o}{=} \PYG{n}{request}\PYG{o}{.}\PYG{n}{authorization}
        \PYG{k}{if} \PYG{o+ow}{not} \PYG{n}{auth} \PYG{o+ow}{or} \PYG{o+ow}{not} \PYG{n}{check\PYGZus{}auth}\PYG{p}{(}\PYG{n}{auth}\PYG{o}{.}\PYG{n}{username}\PYG{p}{,} \PYG{n}{auth}\PYG{o}{.}\PYG{n}{password}\PYG{p}{)}\PYG{p}{:}
            \PYG{k}{return} \PYG{n}{authenticate}\PYG{p}{(}\PYG{p}{)}
        \PYG{k}{return} \PYG{n}{f}\PYG{p}{(}\PYG{o}{*}\PYG{n}{args}\PYG{p}{,} \PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{decorated}
\end{Verbatim}


\section{Logging}
\label{decorators:logging}
Logging is another area where the decorators shine. Here is an example:
\DUspan{keyword,namespace}{}\DUspan{name,namespace}{}\DUspan{keyword,namespace}{}\DUspan{name}{}\DUspan{keyword}{}\DUspan{name,function}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name,decorator}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{name,function}{}\DUspan{punctuation}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{literal,string}{}\DUspan{keyword}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{name}{}\DUspan{name,decorator}{}\DUspan{keyword}{}\DUspan{name,function}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{literal,string,doc}{}\DUspan{keyword}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{comment}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{functools} \PYG{k+kn}{import} \PYG{n}{wraps}

\PYG{k}{def} \PYG{n+nf}{logit}\PYG{p}{(}\PYG{n}{func}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nd}{@wraps}\PYG{p}{(}\PYG{n}{func}\PYG{p}{)}
    \PYG{k}{def} \PYG{n+nf}{with\PYGZus{}logging}\PYG{p}{(}\PYG{o}{*}\PYG{n}{args}\PYG{p}{,} \PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{print} \PYG{n}{func}\PYG{o}{.}\PYG{n}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ was called}\PYG{l+s}{\PYGZdq{}}
        \PYG{k}{return} \PYG{n}{func}\PYG{p}{(}\PYG{o}{*}\PYG{n}{args}\PYG{p}{,} \PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{with\PYGZus{}logging}

\PYG{n+nd}{@logit}
\PYG{k}{def} \PYG{n+nf}{addition\PYGZus{}func}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{:}
   \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}does some math\PYGZdq{}\PYGZdq{}\PYGZdq{}}
   \PYG{k}{return} \PYG{n}{x} \PYG{o}{+} \PYG{n}{x}


\PYG{n}{result} \PYG{o}{=} \PYG{n}{addition\PYGZus{}func}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{c}{\PYGZsh{} Output: addition\PYGZus{}func was called}
\end{Verbatim}

I am sure you are already thinking about some clever uses of decorators.


\chapter{Global \& Return}
\label{global___return::doc}\label{global___return:global-return}
You might have encountered some functions written in python which have a
return keyword in the end of the function. Do you know what it does ? It
is similar to return in other languages. Lets examine this little
function:
\DUspan{keyword}{}\DUspan{name,function}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{comment}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{add}\PYG{p}{(}\PYG{n}{value1}\PYG{p}{,}\PYG{n}{value2}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{n}{value1} \PYG{o}{+} \PYG{n}{value2}

\PYG{n}{result} \PYG{o}{=} \PYG{n}{add}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{k}{print}\PYG{p}{(}\PYG{n}{result}\PYG{p}{)}
\PYG{c}{\PYGZsh{} Output: 8}
\end{Verbatim}

The function above takes two values as input and then output their
addition. We could have also done:
\DUspan{keyword}{}\DUspan{name,function}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{name}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{comment}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{add}\PYG{p}{(}\PYG{n}{value1}\PYG{p}{,}\PYG{n}{value2}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{global} \PYG{n}{result}
    \PYG{n}{result} \PYG{o}{=} \PYG{n}{value1} \PYG{o}{+} \PYG{n}{value2}

\PYG{n}{add}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{k}{print}\PYG{p}{(}\PYG{n}{result}\PYG{p}{)}
\PYG{c}{\PYGZsh{} Output: 8}
\end{Verbatim}

So first lets talk about the first bit of code which involves the
\code{return} keyword. What that function is doing is that it is assigning
the value to the variable which is calling that function which in our
case is \code{result}. In most cases and you won't need to use the
\code{global} keyword. However lets examine the other bit of code as well
which includes the \code{global} keyword. So what that function is doing is
that it is making a global variable \code{result}. What does global mean
here? Global variable means that we can access that variable outside the
scope of the function as well. Let me demonstrate it with an example :
\DUspan{comment}{}\DUspan{keyword}{}\DUspan{name,function}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{comment}{}\DUspan{comment}{}\DUspan{comment}{}\DUspan{comment}{}\DUspan{comment}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{name}{}\DUspan{name}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{operator,word}{}\DUspan{name}{}\DUspan{name,exception}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{literal,string}{}\DUspan{operator,word}{}\DUspan{operator,word}{}\DUspan{name}{}\DUspan{comment}{}\DUspan{comment}{}\DUspan{keyword}{}\DUspan{name,function}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{name}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{literal,number,integer}{}
\begin{Verbatim}[commandchars=\\\{\}]
\# first without the global variable
def add(value1,value2):
    result = value1 + value2

add(2,4)
print(result)

\# Oh crap we encountered an exception. Why is it so ?
\# the python interpreter is telling us that we do not
\# have any variable with the name of result. It is so
\# because the result variable is only accessible inside
\# the function in which it is created if it is not global.
Traceback (most recent call last):
  File "", line 1, in
    result
NameError: name 'result' is not defined

\# Now lets run the same code but after making the result
\# variable global
def add(value1,value2):
    global result
    result = value1 + value2

add(2,4)
result
6
\end{Verbatim}

So hopefully there are no errors in the second run as expected. In
practical programming you should try to stay away from \code{global}
keyword as it only makes life difficult by introducing unwated variables
to the global scope.


\chapter{Mutation}
\label{mutation::doc}\label{mutation:mutation}
The mutable and immutable datatypes in Python cause a lot of headache
for new programmers. In simple words, mutable means `able to be changed'
and immutable means `constant'. Want your head to spin? Consider this
example:
\DUspan{name}{}\DUspan{operator}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{comment}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{comment}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{foo} \PYG{o}{=} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{hi}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
\PYG{k}{print}\PYG{p}{(}\PYG{n}{foo}\PYG{p}{)}
\PYG{c}{\PYGZsh{} Output: [\PYGZsq{}hi\PYGZsq{}]}

\PYG{n}{bar} \PYG{o}{=} \PYG{n}{foo}
\PYG{n}{bar} \PYG{o}{+}\PYG{o}{=} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{bye}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
\PYG{k}{print}\PYG{p}{(}\PYG{n}{foo}\PYG{p}{)}
\PYG{c}{\PYGZsh{} Output: [\PYGZsq{}hi\PYGZsq{}, \PYGZsq{}bye\PYGZsq{}]}
\end{Verbatim}

What just happened? We were not expecting that! We were expecting
something like this:
\DUspan{name}{}\DUspan{operator}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{comment}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{comment}{}\DUspan{keyword}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{comment}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{foo} \PYG{o}{=} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{hi}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
\PYG{k}{print}\PYG{p}{(}\PYG{n}{foo}\PYG{p}{)}
\PYG{c}{\PYGZsh{} Output: [\PYGZsq{}hi\PYGZsq{}]}

\PYG{n}{bar} \PYG{o}{=} \PYG{n}{foo}
\PYG{n}{bar} \PYG{o}{+}\PYG{o}{=} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{bye}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}

\PYG{k}{print}\PYG{p}{(}\PYG{n}{foo}\PYG{p}{)}
\PYG{c}{\PYGZsh{} Output: [\PYGZsq{}hi\PYGZsq{}]}

\PYG{k}{print}\PYG{p}{(}\PYG{n}{bar}\PYG{p}{)}
\PYG{c}{\PYGZsh{} Output: [\PYGZsq{}hi\PYGZsq{}, \PYGZsq{}bye\PYGZsq{}]}
\end{Verbatim}

It's not a bug. It's mutability in action. Whenever you assign a
variable to another variable of mutable datatype, any changes to the
data are reflected by both variables. The new variable is just an alias
for the old variable. This is only true for mutable datatypes. Here is a
gotcha involving functions and mutable data types:
\DUspan{keyword}{}\DUspan{name,function}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{name}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{comment}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{comment}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{comment}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{add\PYGZus{}to}\PYG{p}{(}\PYG{n}{num}\PYG{p}{,} \PYG{n}{target}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{target}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{num}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{target}

\PYG{n}{add\PYGZus{}to}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{c}{\PYGZsh{} Output: [1]}

\PYG{n}{add\PYGZus{}to}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{c}{\PYGZsh{} Output: [1, 2]}

\PYG{n}{add\PYGZus{}to}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{c}{\PYGZsh{} Output: [1, 2, 3]}
\end{Verbatim}

You might have expected it to behave differently. You might be expecting
that a fresh list would be created when you call \code{add\_to} like this:
\DUspan{keyword}{}\DUspan{name,function}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{name}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{comment}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{comment}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{comment}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{add\PYGZus{}to}\PYG{p}{(}\PYG{n}{num}\PYG{p}{,} \PYG{n}{target}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{target}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{num}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{target}

\PYG{n}{add\PYGZus{}to}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{c}{\PYGZsh{} Output: [1]}

\PYG{n}{add\PYGZus{}to}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{c}{\PYGZsh{} Output: [2]}

\PYG{n}{add\PYGZus{}to}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{c}{\PYGZsh{} Output: [3]}
\end{Verbatim}

Well again it is the mutability of lists which causes this pain. In
Python the default arguments are evaluated once when the function is
defined, not each time the function is called. You should never define
default arguments of mutable type unless you know what you are doing.
You should do something like this:
\DUspan{keyword}{}\DUspan{name,function}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name,builtin,pseudo}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{name}{}\DUspan{operator,word}{}\DUspan{name,builtin,pseudo}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{name}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{add\PYGZus{}to}\PYG{p}{(}\PYG{n}{element}\PYG{p}{,} \PYG{n}{target}\PYG{o}{=}\PYG{n+nb+bp}{None}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{if} \PYG{n}{target} \PYG{o+ow}{is} \PYG{n+nb+bp}{None}\PYG{p}{:}
        \PYG{n}{target} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
    \PYG{n}{target}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{element}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{target}
\end{Verbatim}

Now whenever you call the function without the \code{target} argument, a
new list is created. For instance:
\DUspan{name}{}\DUspan{punctuation}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{comment}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{comment}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{comment}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{add\PYGZus{}to}\PYG{p}{(}\PYG{l+m+mi}{42}\PYG{p}{)}
\PYG{c}{\PYGZsh{} Output: [42]}

\PYG{n}{add\PYGZus{}to}\PYG{p}{(}\PYG{l+m+mi}{42}\PYG{p}{)}
\PYG{c}{\PYGZsh{} Output: [42]}

\PYG{n}{add\PYGZus{}to}\PYG{p}{(}\PYG{l+m+mi}{42}\PYG{p}{)}
\PYG{c}{\PYGZsh{} Output: [42]}
\end{Verbatim}


\chapter{\_\_slots\_\_ Magic}
\label{__slots__magic:slots-magic}\label{__slots__magic::doc}
In Python every class can have instance attributes. By default Python
uses a dict to store an object’s instance attributes. This is really
helpful as it allows setting arbitrary new attributes at runtime.

However, in small classes with known attributes it might be a
bottleneck. The \code{dict} wastes a lot of RAM. Python can’t just allocate
a static amount of memory at object creation to store all the
attributes. Therefore it sucks a lot of RAM if you create a lot of
classes (I am talking in thousands and millions). Still there is a way
to circumvent this issue. It involves the useage of \code{\_\_slots\_\_} to
tell Python not to use a dict, and only allocate space for a fixed set
of attributes. Here is an example with and without \code{\_\_slots\_\_}:

\textbf{Without} \code{\_\_slots\_\_}:
\DUspan{keyword}{}\DUspan{name,class}{}\DUspan{punctuation}{}\DUspan{name,builtin}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{name,function}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name,builtin,pseudo}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{name,builtin,pseudo}{}\DUspan{operator}{}\DUspan{keyword}{}\DUspan{error}{}\DUspan{name,class}{}\DUspan{name,builtin,pseudo}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{comment}{}
\begin{Verbatim}[commandchars=\\\{\}]
class MyClass(object):
    def \_\_init\_\_(name, class):
        self.name = name
        self.class = class
        self.set\_up()
    \# ...
\end{Verbatim}

\textbf{With} \code{\_\_slots\_\_}:
\DUspan{keyword}{}\DUspan{name,class}{}\DUspan{punctuation}{}\DUspan{name,builtin}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{name,function}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name,builtin,pseudo}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{name,builtin,pseudo}{}\DUspan{operator}{}\DUspan{keyword}{}\DUspan{error}{}\DUspan{name,class}{}\DUspan{name,builtin,pseudo}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{comment}{}
\begin{Verbatim}[commandchars=\\\{\}]
class MyClass(object):
    \_\_slots\_\_ = ['name', 'class']
    def \_\_init\_\_(name, class):
        self.name = name
        self.class = class
        self.set\_up()
    \# ...
\end{Verbatim}

The second piece of code will reduce the burden on your RAM. Some people
have seen almost 40 to 50\% reduction in RAM usage by using this
technique.

On a sidenote, you might want to give PyPy a try. It does all of these
optimizations by default.


\chapter{Virtual Environment}
\label{virtual_environment::doc}\label{virtual_environment:virtual-environment}

\section{Introducing \texttt{virtualenv}}
\label{virtual_environment:introducing-virtualenv}
Have you ever heard of \code{virtualenv}? The chances are that if you are a
beginner then you might not have heard about it but if you are a
seasoned programmer than it's a vital part of your toolset. So what
\code{virtualenv} really is? \code{Virtualenv} is a tool which allows us to
make isolated python environments. Imagine you have an application that
needs version 2 of a LibraryBar, but another application requires
version 3. How can you use and develop both these applications?

If you install everything into \code{/usr/lib/python2.7/site-packages} (or
whatever your platform's standard location is), it's easy to end up in a
situation where you unintentionally upgrade a package that shouldn't be
upgraded. In another case just imagine that you have an application
which is fully developed and you do not want to make any change to the
libraries it is using but at the same time you start developing another
application which requires the updated versions of those libraries. What
will you do? It is where \code{virtualenv} comes into play. It creates
isolated environments for you python application and allows you to
install Python libraries in that isolated environment instead of
installing them globally.

In order to install it just type this command in the shell:
\DUspan{error}{}\DUspan{name}{}\DUspan{name}{}\DUspan{name}{}
\begin{Verbatim}[commandchars=\\\{\}]
\$ pip install virtualenv
\end{Verbatim}

Now i am going to list some of it's commands. The most important ones
are:
\begin{itemize}
\item {} 
\code{\$ virtualenv myproject}

\item {} 
\code{\$ source bin/activate}

\end{itemize}

This first one makes an isolated virtualenv environment in the
\code{myproject} folder and the second command activates that isolated
environment. While running the first command you have to make a
decision.

Do you want this virtualenv to use packages from your system
\code{site-packages} or install them in the virtualenv’s site-packages? By
default, virtualenv will symlink to your system’s \code{site-packages} if
you install a package in the virtualenv that is already installed on
your system. If you want a totally isolated \code{virtualenv} then you’ll
want to do the latter. To do this, you pass in the
\code{-–no-site-packages} switch when creating your virtualenv like this:
\DUspan{error}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{name}{}
\begin{Verbatim}[commandchars=\\\{\}]
\$ virtualenv --no-site-packages mycoolproject
\end{Verbatim}

Now you can install any library without disturbing the global libraries
or the libraries of the other environments. You can turn off the \code{env}
by typing:
\DUspan{error}{}\DUspan{name}{}
\begin{Verbatim}[commandchars=\\\{\}]
\$ deactivate
\end{Verbatim}


\section{Bonus}
\label{virtual_environment:bonus}
You can use \code{smartcd} which is a library for bash and zsh and allows
you to alter your bash (or zsh) environment as you cd. It can be really
helpful to activate and deactivate a \code{virtualenv} when you change
directories. I have used it quite a lot and love it. You can read more
about it on \href{https://github.com/cxreg/smartcd}{GitHub}

This was just a short intro to virtualenv. There's a lot more to it. For
further study i recommend \href{http://docs.python-guide.org/en/latest/dev/virtualenvs.html}{this
link.}
It will remove all of your confusions about virtualenv.


\chapter{Collections}
\label{collections:collections}\label{collections::doc}
Python ships with a module that contains a number of container data
types called Collections. We will talk about a few of them and discuss
their usefullness.

The ones which we will talk about are:
\begin{itemize}
\item {} 
\code{defaultdict}

\item {} 
\code{counter}

\item {} 
\code{deque}

\end{itemize}


\section{1.\texttt{defaultdict}}
\label{collections:defaultdict}
I personally use defaultdict quite a bit. Unlike \code{dict}, with
\code{defaultdict} you do not need to check whether a key is present or
not. So we can do:
\DUspan{keyword,namespace}{}\DUspan{name,namespace}{}\DUspan{keyword,namespace}{}\DUspan{name}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{punctuation}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name,builtin}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator,word}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{comment}{}\DUspan{comment}{}\DUspan{comment}{}\DUspan{comment}{}\DUspan{comment}{}\DUspan{comment}{}\DUspan{comment}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{collections} \PYG{k+kn}{import} \PYG{n}{defaultdict}

\PYG{n}{colours} \PYG{o}{=} \PYG{p}{(}
    \PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Yasoob}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Yellow}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}
    \PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Ali}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Blue}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}
    \PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Arham}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Green}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}
    \PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Ali}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Black}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}
    \PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Yasoob}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Red}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}
    \PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Ahmed}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Silver}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}
\PYG{p}{)}

\PYG{n}{favourite\PYGZus{}colours} \PYG{o}{=} \PYG{n}{defaultdict}\PYG{p}{(}\PYG{n+nb}{list}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{name}\PYG{p}{,} \PYG{n}{colour} \PYG{o+ow}{in} \PYG{n}{order}\PYG{p}{:}
    \PYG{n}{favourite\PYGZus{}colours}\PYG{p}{[}\PYG{n}{name}\PYG{p}{]}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{colour}\PYG{p}{)}

\PYG{k}{print}\PYG{p}{(}\PYG{n}{favourite\PYGZus{}colours}\PYG{p}{)}

\PYG{c}{\PYGZsh{} output}
\PYG{c}{\PYGZsh{} defaultdict(\PYGZlt{}type \PYGZsq{}list\PYGZsq{}\PYGZgt{},}
\PYG{c}{\PYGZsh{}    \PYGZob{}\PYGZsq{}Arham\PYGZsq{}: [\PYGZsq{}Green\PYGZsq{}],}
\PYG{c}{\PYGZsh{}     \PYGZsq{}Yasoob\PYGZsq{}: [\PYGZsq{}Yellow\PYGZsq{}, \PYGZsq{}Red\PYGZsq{}],}
\PYG{c}{\PYGZsh{}     \PYGZsq{}Ahmed\PYGZsq{}: [\PYGZsq{}Silver\PYGZsq{}],}
\PYG{c}{\PYGZsh{}     \PYGZsq{}Ali\PYGZsq{}: [\PYGZsq{}Blue\PYGZsq{}, \PYGZsq{}Black\PYGZsq{}]}
\PYG{c}{\PYGZsh{} \PYGZcb{})}
\end{Verbatim}

One another very important use case is when you are appending to nested
ists inside a dictionary. If a \code{key} is not already present in the
dictionary then you are greeted with a \code{KeyError}. \code{defaultdict}
allows us to circumvent this issue in a clever way. First let me share
an example using \code{dict} which raises \code{KeyError} and then I will
share a solution using \code{defaultdict}.

\textbf{Problem:}
\DUspan{name}{}\DUspan{operator}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{operator}{}\DUspan{literal,string}{}\DUspan{comment}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{some\PYGZus{}dict} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{n}{some\PYGZus{}dict}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{colours}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{favourite}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{yellow}\PYG{l+s}{\PYGZdq{}}
\PYG{c}{\PYGZsh{} Raises KeyError: \PYGZsq{}colours\PYGZsq{}}
\end{Verbatim}

\textbf{Solution:}
\DUspan{keyword,namespace}{}\DUspan{name,namespace}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{keyword}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{operator}{}\DUspan{literal,string}{}\DUspan{comment}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{collections}
\PYG{n}{tree} \PYG{o}{=} \PYG{k}{lambda}\PYG{p}{:} \PYG{n}{collections}\PYG{o}{.}\PYG{n}{defaultdict}\PYG{p}{(}\PYG{n}{tree}\PYG{p}{)}
\PYG{n}{some\PYGZus{}dict} \PYG{o}{=} \PYG{n}{tree}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{some\PYGZus{}dict}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{colours}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{favourite}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{yellow}\PYG{l+s}{\PYGZdq{}}
\PYG{c}{\PYGZsh{} Works fine}
\end{Verbatim}

You can print the \code{some\_dict} using \code{json.dumps}. Here is some
sample code:
\DUspan{keyword,namespace}{}\DUspan{name,namespace}{}\DUspan{keyword}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{comment}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{json}
\PYG{k}{print}\PYG{p}{(}\PYG{n}{json}\PYG{o}{.}\PYG{n}{dumps}\PYG{p}{(}\PYG{n}{some\PYGZus{}dict}\PYG{p}{)}\PYG{p}{)}
\PYG{c}{\PYGZsh{} Output: \PYGZob{}\PYGZdq{}colours\PYGZdq{}: \PYGZob{}\PYGZdq{}favourite\PYGZdq{}: \PYGZdq{}yellow\PYGZdq{}\PYGZcb{}\PYGZcb{}}
\end{Verbatim}


\section{2.\texttt{counter}}
\label{collections:counter}
Counter allows us to count the occurances of a particular item. For
instance it can be used to count the number of individual favourite
colours:
\DUspan{keyword,namespace}{}\DUspan{name,namespace}{}\DUspan{keyword,namespace}{}\DUspan{name}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{punctuation}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{keyword}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator,word}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{comment}{}\DUspan{comment}{}\DUspan{comment}{}\DUspan{comment}{}\DUspan{comment}{}\DUspan{comment}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{collections} \PYG{k+kn}{import} \PYG{n}{Counter}

\PYG{n}{colours} \PYG{o}{=} \PYG{p}{(}
    \PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Yasoob}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Yellow}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}
    \PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Ali}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Blue}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}
    \PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Arham}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Green}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}
    \PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Ali}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Black}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}
    \PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Yasoob}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Red}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}
    \PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Ahmed}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Silver}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}
\PYG{p}{)}

\PYG{n}{favs} \PYG{o}{=} \PYG{n}{Counter}\PYG{p}{(}\PYG{n}{name} \PYG{k}{for} \PYG{n}{name}\PYG{p}{,} \PYG{n}{colour} \PYG{o+ow}{in} \PYG{n}{colours}\PYG{p}{)}
\PYG{k}{print}\PYG{p}{(}\PYG{n}{favs}\PYG{p}{)}
\PYG{c}{\PYGZsh{} Output: Counter(\PYGZob{}}
\PYG{c}{\PYGZsh{}    \PYGZsq{}Yasoob\PYGZsq{}: 2,}
\PYG{c}{\PYGZsh{}    \PYGZsq{}Ali\PYGZsq{}: 2,}
\PYG{c}{\PYGZsh{}    \PYGZsq{}Arham\PYGZsq{}: 1,}
\PYG{c}{\PYGZsh{}    \PYGZsq{}Ahmed\PYGZsq{}: 1}
\PYG{c}{\PYGZsh{} \PYGZcb{})}
\end{Verbatim}

We can also count the most common lines in a file using it. For example:
\DUspan{keyword}{}\DUspan{name,builtin}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{with} \PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{filename}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{rb}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{f}\PYG{p}{:}
    \PYG{n}{line\PYGZus{}count} \PYG{o}{=} \PYG{n}{Counter}\PYG{p}{(}\PYG{n}{f}\PYG{p}{)}
\PYG{k}{print}\PYG{p}{(}\PYG{n}{line\PYGZus{}count}\PYG{p}{)}
\end{Verbatim}


\section{3.\texttt{deque}}
\label{collections:deque}
\code{deque} provides you with a double ended queue which means that you
can append and delete elements from either side of the queue. First of
all you have to import the deque module from the collections library:
\DUspan{keyword,namespace}{}\DUspan{name,namespace}{}\DUspan{keyword,namespace}{}\DUspan{name}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{collections} \PYG{k+kn}{import} \PYG{n}{deque}
\end{Verbatim}

Now we can instantiate a deque object.
\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{d} \PYG{o}{=} \PYG{n}{deque}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

It works like python lists and provides you with somewhat similar
methods as well. For example you can do:
\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{punctuation}{}\DUspan{name,builtin}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{comment}{}\DUspan{keyword}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{comment}{}\DUspan{keyword}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{operator}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{comment}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{d} \PYG{o}{=} \PYG{n}{deque}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{d}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{1}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{d}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{2}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{d}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{3}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}

\PYG{k}{print}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{d}\PYG{p}{)}\PYG{p}{)}
\PYG{c}{\PYGZsh{} Output: 3}

\PYG{k}{print}\PYG{p}{(}\PYG{n}{d}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{c}{\PYGZsh{} Output: \PYGZsq{}1\PYGZsq{}}

\PYG{k}{print}\PYG{p}{(}\PYG{n}{d}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{c}{\PYGZsh{} Output: \PYGZsq{}3\PYGZsq{}}
\end{Verbatim}

You can pop values from both sides of the deque:
\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{keyword}{}\DUspan{name}{}\DUspan{operator,word}{}\DUspan{name,builtin}{}\DUspan{punctuation}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{punctuation}{}\DUspan{name,builtin}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{comment}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{comment}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{comment}{}\DUspan{keyword}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{comment}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{d} \PYG{o}{=} \PYG{n}{deque}\PYG{p}{(}\PYG{p}{[}\PYG{n}{i} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}
\PYG{k}{print}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{d}\PYG{p}{)}\PYG{p}{)}
\PYG{c}{\PYGZsh{} Output: 5}

\PYG{n}{d}\PYG{o}{.}\PYG{n}{popleft}\PYG{p}{(}\PYG{p}{)}
\PYG{c}{\PYGZsh{} Output: 0}

\PYG{n}{d}\PYG{o}{.}\PYG{n}{pop}\PYG{p}{(}\PYG{p}{)}
\PYG{c}{\PYGZsh{} Output: 4}

\PYG{k}{print}\PYG{p}{(}\PYG{n}{d}\PYG{p}{)}
\PYG{c}{\PYGZsh{} Output: deque([1, 2, 3])}
\end{Verbatim}

We can also limit the amount of items a deque can hold. By doing this
when we achieve the maximum limit of out deque it will simply pop out
the items from the opposite end. It is better to explain it using an
example so here you go:
\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{d} \PYG{o}{=} \PYG{n}{deque}\PYG{p}{(}\PYG{n}{maxlen}\PYG{o}{=}\PYG{l+m+mi}{30}\PYG{p}{)}
\end{Verbatim}

Now whenever you insert values after 30, the leftmost value will be
popped from the list. You can also expand the list in any direction with
new values:
\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{comment}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{d} \PYG{o}{=} \PYG{n}{deque}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{d}\PYG{o}{.}\PYG{n}{extendleft}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{d}\PYG{o}{.}\PYG{n}{extend}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{]}\PYG{p}{)}
\PYG{k}{print}\PYG{p}{(}\PYG{n}{d}\PYG{p}{)}
\PYG{c}{\PYGZsh{} Output: deque([0, 1, 2, 3, 4, 5, 6, 7, 8])}
\end{Verbatim}

This was just a quick drive through the \code{collections} module. Make
sure you read the official documentation after reading this.


\chapter{Enumerate}
\label{enumerate::doc}\label{enumerate:enumerate}
Enumerate is a built-in function of Python. It's usefulness can not be
summarized in a single line. Yet most of the newcommers and even some
advanced programmers are unaware of it. It allows us to loop over
something and have an automatic counter. Here is an example:
\DUspan{keyword}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator,word}{}\DUspan{name,builtin}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{n}{counter}\PYG{p}{,} \PYG{n}{value} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{some\PYGZus{}list}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{print}\PYG{p}{(}\PYG{n}{counter}\PYG{p}{,} \PYG{n}{value}\PYG{p}{)}
\end{Verbatim}

This is not it. \code{enumerate} also accepts some optional arguments which
make it even more useful.
\DUspan{name}{}\DUspan{operator}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator,word}{}\DUspan{name,builtin}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{comment}{}\DUspan{comment}{}\DUspan{comment}{}\DUspan{comment}{}\DUspan{comment}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{my\PYGZus{}list} \PYG{o}{=} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{apple}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{banana}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{grapes}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{pear}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{c}\PYG{p}{,} \PYG{n}{value} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{my\PYGZus{}list}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{print}\PYG{p}{(}\PYG{n}{c}\PYG{p}{,} \PYG{n}{value}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Output:}
\PYG{c}{\PYGZsh{} 1 apple}
\PYG{c}{\PYGZsh{} 2 banana}
\PYG{c}{\PYGZsh{} 3 grapes}
\PYG{c}{\PYGZsh{} 4 pear}
\end{Verbatim}

The optional argument allows us to tell \code{enumerate} from where to
start the index. You can also create tuples containing the index and
list item using a list. Here is an example:
\DUspan{name}{}\DUspan{operator}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name,builtin}{}\DUspan{punctuation}{}\DUspan{name,builtin}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{comment}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{my\PYGZus{}list} \PYG{o}{=} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{apple}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{banana}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{grapes}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{pear}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{counter\PYGZus{}list} \PYG{o}{=} \PYG{n+nb}{list}\PYG{p}{(}\PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{my\PYGZus{}list}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{print}\PYG{p}{(}\PYG{n}{counter\PYGZus{}list}\PYG{p}{)}
\PYG{c}{\PYGZsh{} Output: [(1, \PYGZsq{}apple\PYGZsq{}), (2, \PYGZsq{}banana\PYGZsq{}), (3, \PYGZsq{}grapes\PYGZsq{}), (4, \PYGZsq{}pear\PYGZsq{})]}
\end{Verbatim}


\chapter{Object introspection}
\label{object_introspection:object-introspection}\label{object_introspection::doc}
In computer programming, introspection is the ability to determine the
type of an object at runtime. It is one of Python's strengths.
Everything in Python is an object and we can examine those objects.
Python ships with a few Built-in functions and modules to help us.


\section{1.\texttt{dir()} BIF}
\label{object_introspection:dir-bif}
In this section we will learn about \code{dir()} and how it facilitates us
in introspection.

It is one of the most important functions for introspection. It returns
a list of attributes and methods belonging to an object. Here is an
example:
\DUspan{name}{}\DUspan{operator}{}\DUspan{punctuation}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{name,builtin}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{comment}{}\DUspan{comment}{}\DUspan{comment}{}\DUspan{comment}{}\DUspan{comment}{}\DUspan{comment}{}\DUspan{comment}{}\DUspan{comment}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{my\PYGZus{}list} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}
\PYG{n+nb}{dir}\PYG{p}{(}\PYG{n}{my\PYGZus{}list}\PYG{p}{)}
\PYG{c}{\PYGZsh{} Output: [\PYGZsq{}\PYGZus{}\PYGZus{}add\PYGZus{}\PYGZus{}\PYGZsq{}, \PYGZsq{}\PYGZus{}\PYGZus{}class\PYGZus{}\PYGZus{}\PYGZsq{}, \PYGZsq{}\PYGZus{}\PYGZus{}contains\PYGZus{}\PYGZus{}\PYGZsq{}, \PYGZsq{}\PYGZus{}\PYGZus{}delattr\PYGZus{}\PYGZus{}\PYGZsq{}, \PYGZsq{}\PYGZus{}\PYGZus{}delitem\PYGZus{}\PYGZus{}\PYGZsq{},}
\PYG{c}{\PYGZsh{} \PYGZsq{}\PYGZus{}\PYGZus{}delslice\PYGZus{}\PYGZus{}\PYGZsq{}, \PYGZsq{}\PYGZus{}\PYGZus{}doc\PYGZus{}\PYGZus{}\PYGZsq{}, \PYGZsq{}\PYGZus{}\PYGZus{}eq\PYGZus{}\PYGZus{}\PYGZsq{}, \PYGZsq{}\PYGZus{}\PYGZus{}format\PYGZus{}\PYGZus{}\PYGZsq{}, \PYGZsq{}\PYGZus{}\PYGZus{}ge\PYGZus{}\PYGZus{}\PYGZsq{}, \PYGZsq{}\PYGZus{}\PYGZus{}getattribute\PYGZus{}\PYGZus{}\PYGZsq{},}
\PYG{c}{\PYGZsh{} \PYGZsq{}\PYGZus{}\PYGZus{}getitem\PYGZus{}\PYGZus{}\PYGZsq{}, \PYGZsq{}\PYGZus{}\PYGZus{}getslice\PYGZus{}\PYGZus{}\PYGZsq{}, \PYGZsq{}\PYGZus{}\PYGZus{}gt\PYGZus{}\PYGZus{}\PYGZsq{}, \PYGZsq{}\PYGZus{}\PYGZus{}hash\PYGZus{}\PYGZus{}\PYGZsq{}, \PYGZsq{}\PYGZus{}\PYGZus{}iadd\PYGZus{}\PYGZus{}\PYGZsq{}, \PYGZsq{}\PYGZus{}\PYGZus{}imul\PYGZus{}\PYGZus{}\PYGZsq{},}
\PYG{c}{\PYGZsh{} \PYGZsq{}\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}\PYGZsq{}, \PYGZsq{}\PYGZus{}\PYGZus{}iter\PYGZus{}\PYGZus{}\PYGZsq{}, \PYGZsq{}\PYGZus{}\PYGZus{}le\PYGZus{}\PYGZus{}\PYGZsq{}, \PYGZsq{}\PYGZus{}\PYGZus{}len\PYGZus{}\PYGZus{}\PYGZsq{}, \PYGZsq{}\PYGZus{}\PYGZus{}lt\PYGZus{}\PYGZus{}\PYGZsq{}, \PYGZsq{}\PYGZus{}\PYGZus{}mul\PYGZus{}\PYGZus{}\PYGZsq{}, \PYGZsq{}\PYGZus{}\PYGZus{}ne\PYGZus{}\PYGZus{}\PYGZsq{},}
\PYG{c}{\PYGZsh{} \PYGZsq{}\PYGZus{}\PYGZus{}new\PYGZus{}\PYGZus{}\PYGZsq{}, \PYGZsq{}\PYGZus{}\PYGZus{}reduce\PYGZus{}\PYGZus{}\PYGZsq{}, \PYGZsq{}\PYGZus{}\PYGZus{}reduce\PYGZus{}ex\PYGZus{}\PYGZus{}\PYGZsq{}, \PYGZsq{}\PYGZus{}\PYGZus{}repr\PYGZus{}\PYGZus{}\PYGZsq{}, \PYGZsq{}\PYGZus{}\PYGZus{}reversed\PYGZus{}\PYGZus{}\PYGZsq{}, \PYGZsq{}\PYGZus{}\PYGZus{}rmul\PYGZus{}\PYGZus{}\PYGZsq{},}
\PYG{c}{\PYGZsh{} \PYGZsq{}\PYGZus{}\PYGZus{}setattr\PYGZus{}\PYGZus{}\PYGZsq{}, \PYGZsq{}\PYGZus{}\PYGZus{}setitem\PYGZus{}\PYGZus{}\PYGZsq{}, \PYGZsq{}\PYGZus{}\PYGZus{}setslice\PYGZus{}\PYGZus{}\PYGZsq{}, \PYGZsq{}\PYGZus{}\PYGZus{}sizeof\PYGZus{}\PYGZus{}\PYGZsq{}, \PYGZsq{}\PYGZus{}\PYGZus{}str\PYGZus{}\PYGZus{}\PYGZsq{},}
\PYG{c}{\PYGZsh{} \PYGZsq{}\PYGZus{}\PYGZus{}subclasshook\PYGZus{}\PYGZus{}\PYGZsq{}, \PYGZsq{}append\PYGZsq{}, \PYGZsq{}count\PYGZsq{}, \PYGZsq{}extend\PYGZsq{}, \PYGZsq{}index\PYGZsq{}, \PYGZsq{}insert\PYGZsq{}, \PYGZsq{}pop\PYGZsq{},}
\PYG{c}{\PYGZsh{} \PYGZsq{}remove\PYGZsq{}, \PYGZsq{}reverse\PYGZsq{}, \PYGZsq{}sort\PYGZsq{}]}
\end{Verbatim}

Our introspection gave us the names of all the methods of a list. This
can be handy when you are not able to recall a method name. If we run
\code{dir()} without any argument then it returns all names in the current
scope.


\section{2.\texttt{type()} and \texttt{id()}}
\label{object_introspection:type-and-id}
The \code{type} function returns the type of an object. For example:
\DUspan{keyword}{}\DUspan{punctuation}{}\DUspan{name,builtin}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{comment}{}\DUspan{keyword}{}\DUspan{punctuation}{}\DUspan{name,builtin}{}\DUspan{punctuation}{}\DUspan{comment}{}\DUspan{keyword}{}\DUspan{punctuation}{}\DUspan{name,builtin}{}\DUspan{punctuation}{}\DUspan{comment}{}\DUspan{keyword}{}\DUspan{punctuation}{}\DUspan{name,builtin}{}\DUspan{punctuation}{}\DUspan{name,builtin}{}\DUspan{punctuation}{}\DUspan{comment}{}\DUspan{keyword}{}\DUspan{punctuation}{}\DUspan{name,builtin}{}\DUspan{punctuation}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{comment}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print}\PYG{p}{(}\PYG{n+nb}{type}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{c}{\PYGZsh{} Output: \PYGZlt{}type \PYGZsq{}str\PYGZsq{}\PYGZgt{}}

\PYG{k}{print}\PYG{p}{(}\PYG{n+nb}{type}\PYG{p}{(}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{c}{\PYGZsh{} Output: \PYGZlt{}type \PYGZsq{}list\PYGZsq{}\PYGZgt{}}

\PYG{k}{print}\PYG{p}{(}\PYG{n+nb}{type}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{)}
\PYG{c}{\PYGZsh{} Output: \PYGZlt{}type \PYGZsq{}dict\PYGZsq{}\PYGZgt{}}

\PYG{k}{print}\PYG{p}{(}\PYG{n+nb}{type}\PYG{p}{(}\PYG{n+nb}{bool}\PYG{p}{)}\PYG{p}{)}
\PYG{c}{\PYGZsh{} Output: \PYGZlt{}type \PYGZsq{}type\PYGZsq{}\PYGZgt{}}

\PYG{k}{print}\PYG{p}{(}\PYG{n+nb}{type}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}
\PYG{c}{\PYGZsh{} Output: \PYGZlt{}type \PYGZsq{}int\PYGZsq{}\PYGZgt{}}
\end{Verbatim}

\code{id} returns the unique ids of various objects. For instance:
\DUspan{name}{}\DUspan{operator}{}\DUspan{literal,string}{}\DUspan{keyword}{}\DUspan{punctuation}{}\DUspan{name,builtin}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{comment}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{name} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Yasoob}\PYG{l+s}{\PYGZdq{}}
\PYG{k}{print}\PYG{p}{(}\PYG{n+nb}{id}\PYG{p}{(}\PYG{n}{name}\PYG{p}{)}\PYG{p}{)}
\PYG{c}{\PYGZsh{} Output: 139972439030304}
\end{Verbatim}


\section{3.\texttt{inspect} module}
\label{object_introspection:inspect-module}
The inspect module also provides several useful functions to get
information about live objects. For example you can check the members of
an object by running:
\DUspan{keyword,namespace}{}\DUspan{name,namespace}{}\DUspan{keyword}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name,builtin}{}\DUspan{punctuation}{}\DUspan{comment}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{inspect}
\PYG{k}{print}\PYG{p}{(}\PYG{n}{inspect}\PYG{o}{.}\PYG{n}{getmembers}\PYG{p}{(}\PYG{n+nb}{str}\PYG{p}{)}\PYG{p}{)}
\PYG{c}{\PYGZsh{} Output: [(\PYGZsq{}\PYGZus{}\PYGZus{}add\PYGZus{}\PYGZus{}\PYGZsq{}, \PYGZlt{}slot wrapper \PYGZsq{}\PYGZus{}\PYGZus{}add\PYGZus{}\PYGZus{}\PYGZsq{} of ... ...}
\end{Verbatim}

There are a couple of other methods as well which help in introspection.
You can explore them if you wish.


\chapter{Comprehensions}
\label{comprehensions::doc}\label{comprehensions:comprehensions}
Comprehensions are a feature of Python which I would really miss if I
ever have to leave it. Comprehensions are constructs that allow
sequences to be built from other sequences. There are three type of
comprehensions in Python:
\begin{itemize}
\item {} 
list comprehensions

\item {} 
dictionary comprehensions

\item {} 
set comprehensions

\end{itemize}

\code{list} comprehensions were introduced in Python 2. \code{set} and
\code{dictionary} comprehensions became a part of Python in version 3.0.

We will discuss them one by one. Once you get the hang of using \code{list}
comprehensions then you can use anyone of them easily.


\section{\texttt{list} comprehensions}
\label{comprehensions:list-comprehensions}
List comprehensions provide a short and concise way to create lists. It
consists of square brackets containing an expression followed by a
\code{for} clause, then zero or more \code{for} or \code{if} clauses. The
expressions can be anything, meaning you can put in all kinds of objects
in lists. The result would be a new list made after the evaluation of
the expression in context of the \code{if} and \code{for} clauses.

\textbf{Blueprint}
\DUspan{name}{}\DUspan{operator}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{keyword}{}\DUspan{name}{}\DUspan{operator,word}{}\DUspan{name}{}\DUspan{keyword}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{variable} \PYG{o}{=} \PYG{p}{[}\PYG{n}{out\PYGZus{}exp} \PYG{k}{for} \PYG{n}{out\PYGZus{}exp} \PYG{o+ow}{in} \PYG{n}{input\PYGZus{}list} \PYG{k}{if} \PYG{n}{out\PYGZus{}exp} \PYG{o}{==} \PYG{l+m+mi}{2}\PYG{p}{]}
\end{Verbatim}

Here is a short example:
\DUspan{name}{}\DUspan{operator}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{keyword}{}\DUspan{name}{}\DUspan{operator,word}{}\DUspan{name,builtin}{}\DUspan{punctuation}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{literal,number,integer}{}\DUspan{operator,word}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{comment}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{multiples} \PYG{o}{=} \PYG{p}{[}\PYG{n}{i} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{30}\PYG{p}{)} \PYG{k}{if} \PYG{n}{i} \PYG{o}{\PYGZpc{}} \PYG{l+m+mi}{3} \PYG{o+ow}{is} \PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{k}{print}\PYG{p}{(}\PYG{n}{multiples}\PYG{p}{)}
\PYG{c}{\PYGZsh{} Output: [0, 3, 6, 9, 12, 15, 18, 21, 24, 27]}
\end{Verbatim}

This can be really useful to make lists quickly. It is even preferred by
some instead of \code{filter} function. \code{list} comprehensions really
shine when you want to supply a list to a method or function to make a
new list by appending to it in each iteration of the \code{for} loop. For
instance you would usually do something like this:
\DUspan{name}{}\DUspan{operator}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{name}{}\DUspan{operator,word}{}\DUspan{name,builtin}{}\DUspan{punctuation}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{squared} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{x} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{squared}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{x}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}
\end{Verbatim}

You can simplify it using \code{list} comprehensions. For example:
\DUspan{name}{}\DUspan{operator}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{literal,number,integer}{}\DUspan{keyword}{}\DUspan{name}{}\DUspan{operator,word}{}\DUspan{name,builtin}{}\DUspan{punctuation}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{squared} \PYG{o}{=} \PYG{p}{[}\PYG{n}{x}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{k}{for} \PYG{n}{x} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{]}
\end{Verbatim}


\section{\texttt{dict} comprehensions}
\label{comprehensions:dict-comprehensions}
They are used in a similar way. Here is an example which I found
recently:
\DUspan{name}{}\DUspan{operator}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{name}{}\DUspan{operator,word}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{punctuation}{}\DUspan{comment}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{mcase} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{a}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{b}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{34}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{A}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Z}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{3}\PYG{p}{\PYGZcb{}}

\PYG{n}{mcase\PYGZus{}frequency} \PYG{o}{=} \PYG{p}{\PYGZob{}} \PYG{n}{k}\PYG{o}{.}\PYG{n}{lower}\PYG{p}{(}\PYG{p}{)} \PYG{p}{:} \PYG{n}{mcase}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{n}{k}\PYG{o}{.}\PYG{n}{lower}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{+} \PYGZbs{}
\PYG{n}{mcase}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{n}{k}\PYG{o}{.}\PYG{n}{upper}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n}{mcase}\PYG{o}{.}\PYG{n}{keys}\PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZcb{}}

\PYG{c}{\PYGZsh{} mcase\PYGZus{}frequency == \PYGZob{}\PYGZsq{}a\PYGZsq{}: 17, \PYGZsq{}z\PYGZsq{}: 3, \PYGZsq{}b\PYGZsq{}: 34\PYGZcb{}}
\end{Verbatim}

In the above example we are combining the values of keys which are same
but in different typecase. I personally do not use \code{dict}
comprehensions a lot. You can also quickly reverse a dictionary:
\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{keyword}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator,word}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{\PYGZob{}}\PYG{n}{v}\PYG{p}{:} \PYG{n}{k} \PYG{k}{for} \PYG{n}{k}\PYG{p}{,} \PYG{n}{v} \PYG{o+ow}{in} \PYG{n}{some\PYGZus{}dict}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}\PYG{p}{\PYGZcb{}}
\end{Verbatim}


\section{\texttt{set} comprehensions}
\label{comprehensions:set-comprehensions}
They are also similar to list comprehensions. The only difference is
that they use round brackets \code{()} and return a generator. Here is an
example:
\DUspan{name}{}\DUspan{operator}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{literal,number,integer}{}\DUspan{keyword}{}\DUspan{name}{}\DUspan{operator,word}{}\DUspan{name,builtin}{}\DUspan{punctuation}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{comment}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{comment}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{squared} \PYG{o}{=} \PYG{p}{(}\PYG{n}{x}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{k}{for} \PYG{n}{x} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{print}\PYG{p}{(}\PYG{n}{squared}\PYG{p}{)}
\PYG{c}{\PYGZsh{} Output: \PYGZlt{}generator object \PYGZlt{}genexpr\PYGZgt{} at 0x00000000029931B0\PYGZgt{}}
\PYG{n}{squared}\PYG{o}{.}\PYG{n}{next}\PYG{p}{(}\PYG{p}{)}
\PYG{c}{\PYGZsh{} Output: 0}
\end{Verbatim}


\chapter{Exceptions}
\label{exceptions:exceptions}\label{exceptions::doc}
Exception handling is an art which once you master grants you immense
powers. I am going to show you some of the ways in which we can handle
exceptions.

In basic terminology we are aware of \code{try/except} clause. The code
which can cause an exception to occur is put in the \code{try} block and
the handling of the exception is implemented in the \code{except} block.
Here is a simple example:
\DUspan{keyword}{}\DUspan{punctuation}{}\DUspan{name,builtin}{}\DUspan{operator}{}\DUspan{name,builtin}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{name,exception}{}\DUspan{keyword}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{operator}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{try}\PYG{p}{:}
    \PYG{n+nb}{file} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{test.txt}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{rb}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{except} \PYG{n+ne}{IOError} \PYG{k}{as} \PYG{n}{e}\PYG{p}{:}
    \PYG{k}{print}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{An IOError occured. \PYGZob{}\PYGZcb{}}\PYG{l+s}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{e}\PYG{o}{.}\PYG{n}{args}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

In the above example we are handling only the IOError exception. What
most beginners do not know is that we can handle multiple exceptions.


\section{Handling multiple exceptions:}
\label{exceptions:handling-multiple-exceptions}
We can use three methods to handle multiple exceptions. The first one
involves putting all the exceptions which are likely to occur in a
tuple. Like so:
\DUspan{keyword}{}\DUspan{punctuation}{}\DUspan{name,builtin}{}\DUspan{operator}{}\DUspan{name,builtin}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{punctuation}{}\DUspan{name,exception}{}\DUspan{punctuation}{}\DUspan{name,exception}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{operator}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{try}\PYG{p}{:}
    \PYG{n+nb}{file} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{test.txt}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{rb}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{except} \PYG{p}{(}\PYG{n+ne}{IOError}\PYG{p}{,}\PYG{n+ne}{EOFError}\PYG{p}{)} \PYG{k}{as} \PYG{n}{e}\PYG{p}{:}
    \PYG{k}{print}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{An error occured. \PYGZob{}\PYGZcb{}}\PYG{l+s}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{e}\PYG{o}{.}\PYG{n}{args}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

Another method is to handle individual exception in a separate except
block. We can have as many except blocks as we want. Here is an example:
\DUspan{keyword}{}\DUspan{punctuation}{}\DUspan{name,builtin}{}\DUspan{operator}{}\DUspan{name,builtin}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{name,exception}{}\DUspan{keyword}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{name}{}\DUspan{keyword}{}\DUspan{name,exception}{}\DUspan{keyword}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{name}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{try}\PYG{p}{:}
    \PYG{n+nb}{file} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{test.txt}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{rb}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{except} \PYG{n+ne}{EOFError} \PYG{k}{as} \PYG{n}{e}\PYG{p}{:}
    \PYG{k}{print}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{An EOF error occured.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
    \PYG{k}{raise} \PYG{n}{e}
\PYG{k}{except} \PYG{n+ne}{IOError} \PYG{k}{as} \PYG{n}{e}\PYG{p}{:}
    \PYG{k}{print}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{An error occured.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
    \PYG{k}{raise} \PYG{n}{e}
\end{Verbatim}

This way if the exception is not handled by the first except block then
it is passed on to the second block. Now the last method involves
traping ALL exceptions:
\DUspan{keyword}{}\DUspan{punctuation}{}\DUspan{name,builtin}{}\DUspan{operator}{}\DUspan{name,builtin}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{punctuation}{}\DUspan{comment}{}\DUspan{keyword}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{try}\PYG{p}{:}
    \PYG{n+nb}{file} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{test.txt}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{rb}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{except}\PYG{p}{:}
    \PYG{c}{\PYGZsh{} Some loggin if you want}
    \PYG{k}{raise}
\end{Verbatim}

This can be helpful when you have no idea about the exception which can
be thrown by your program.


\subsection{\texttt{Finally} caluse}
\label{exceptions:finally-caluse}
We wrap our main code in the try clause. After that we wrap some code in
except clause which gets executed if an exception occurs in the code
wrapped in try clause. But in this example we will use a third clause as
well which is the \code{finally} clause. The code which is wrapped in the
finally clause will run even if no exception occurs. It might be used
for cleaning up after a script. Here is a simple example:
\DUspan{keyword}{}\DUspan{punctuation}{}\DUspan{name,builtin}{}\DUspan{operator}{}\DUspan{name,builtin}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{name,exception}{}\DUspan{keyword}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{operator}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{comment}{}\DUspan{comment}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{try}\PYG{p}{:}
    \PYG{n+nb}{file} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{test.txt}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{rb}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{except} \PYG{n+ne}{IOError} \PYG{k}{as} \PYG{n}{e}\PYG{p}{:}
    \PYG{k}{print}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{An IOError occured. \PYGZob{}\PYGZcb{}}\PYG{l+s}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{e}\PYG{o}{.}\PYG{n}{args}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{finally}\PYG{p}{:}
    \PYG{k}{print}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{This would be printed even if no exception occurs!}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Output: An IOError occured. No such file or directory}
\PYG{c}{\PYGZsh{} This would be printed even if no exception occurs!}
\end{Verbatim}


\subsection{\texttt{try/else} clause}
\label{exceptions:try-else-clause}
Often times we might want some code to run IF no exception occurs. This
can easily be achieved by using an \code{else} clause. Most people don't
use it and honestly I have myself not used it widely. Here is an
example:
\DUspan{keyword}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{comment}{}\DUspan{comment}{}\DUspan{comment}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{try}\PYG{p}{:}
    \PYG{k}{print}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{I am sure no exception is going to occur!}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{except}\PYG{p}{:}
    \PYG{k}{print}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{exception}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{k}{else}\PYG{p}{:}
    \PYG{k}{print}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{This would only run if no exception occurs.}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{finally}\PYG{p}{:}
    \PYG{k}{print}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{This would be printed in every case.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}

\PYG{c}{\PYGZsh{} Output: I am sure no exception is going to occur!}
\PYG{c}{\PYGZsh{} This would only run if no exception occurs.}
\PYG{c}{\PYGZsh{} This would be printed in every case.}
\end{Verbatim}

The else clause would only run if no exception occurs and it would run
before the \code{finally} clause.


\chapter{Lambdas}
\label{lambdas::doc}\label{lambdas:lambdas}
Lambdas are one line functions. They are also known as annonymous
functions in some other languages. You might want to use lambdas when
you don't want to use a function twice in a program. They are just like
normal functions and even behave like them.

\textbf{Blueprint}
\DUspan{keyword}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{lambda} \PYG{n}{argument}\PYG{p}{:} \PYG{n}{manipulate}\PYG{p}{(}\PYG{n}{argument}\PYG{p}{)}
\end{Verbatim}

\textbf{Example}
\DUspan{name}{}\DUspan{operator}{}\DUspan{keyword}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{keyword}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{comment}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{add} \PYG{o}{=} \PYG{k}{lambda} \PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{:} \PYG{n}{x}\PYG{o}{+}\PYG{n}{y}

\PYG{k}{print}\PYG{p}{(}\PYG{n}{add}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}
\PYG{c}{\PYGZsh{} Output: 8}
\end{Verbatim}

Here are a few useful use cases for lambdas and just a few way in which
they are used in the wild:

\textbf{List sorting}
\DUspan{name}{}\DUspan{operator}{}\DUspan{punctuation}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{punctuation}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{punctuation}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{punctuation}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{operator}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{keyword}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{comment}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{a} \PYG{o}{=} \PYG{p}{[}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{9}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+m+mi}{13}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{]}
\PYG{n}{a}\PYG{o}{.}\PYG{n}{sort}\PYG{p}{(}\PYG{n}{key}\PYG{o}{=}\PYG{k}{lambda} \PYG{n}{x}\PYG{p}{:} \PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}

\PYG{k}{print}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}
\PYG{c}{\PYGZsh{} Output: [(13, \PYGZhy{}3), (4, 1), (1, 2), (9, 10)]}
\end{Verbatim}

\textbf{Parallel sorting of lists}
\DUspan{name}{}\DUspan{operator}{}\DUspan{name,builtin}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name,builtin}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name,builtin}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name,builtin}{}\DUspan{punctuation}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{data} \PYG{o}{=} \PYG{n+nb}{zip}\PYG{p}{(}\PYG{n}{list1}\PYG{p}{,} \PYG{n}{list2}\PYG{p}{)}
\PYG{n}{data}\PYG{o}{.}\PYG{n}{sort}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{list1}\PYG{p}{,} \PYG{n}{list2} \PYG{o}{=} \PYG{n+nb}{map}\PYG{p}{(}\PYG{k}{lambda} \PYG{n}{t}\PYG{p}{:} \PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}\PYG{p}{,} \PYG{n+nb}{zip}\PYG{p}{(}\PYG{o}{*}\PYG{n}{data}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

Note: We will learn about map in a later chapter so don't worry!


\chapter{One Liners}
\label{one_liners:one-liners}\label{one_liners::doc}
In this chapter I will show you some one liner Python commands which can
be really helpful sometimes.

\textbf{Simple Webserver}

Ever wanted to quickly share a file over a network? Well you are in
luck. Python has a similar feature just for you. Go to the directory
which you want to serve over network and write the following code in
terminal:
\DUspan{comment}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{name}{}\DUspan{comment}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}
\begin{Verbatim}[commandchars=\\\{\}]
\# Python 2
python -m SimpleHTTPServer

\# Python 3
python -m http.server
\end{Verbatim}

\textbf{Pretty printing}

You can print a list and dictionary in a beautiful format in Python
repl. Here is the relevant code:
\DUspan{keyword,namespace}{}\DUspan{name,namespace}{}\DUspan{keyword,namespace}{}\DUspan{name}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{pprint} \PYG{k+kn}{import} \PYG{n}{pprint}

\PYG{n}{my\PYGZus{}dict} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{name}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Yasoob}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}
\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{age}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{undefined}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{personality}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{awesome}\PYG{l+s}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}
\PYG{n}{pprint}\PYG{p}{(}\PYG{n}{my\PYGZus{}dict}\PYG{p}{)}
\end{Verbatim}

This is more effective on dicts. Moreover, if you want to pretty print
json quickly from a file then you can simply do:
\DUspan{name}{}\DUspan{name,builtin}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}
\begin{Verbatim}[commandchars=\\\{\}]
cat file.json \textbar{} python -m json.tools
\end{Verbatim}

\textbf{Profiling a script}

This can be extremely helpful in pin pointing the bottlenecks in your
scripts.
\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{name}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}
\begin{Verbatim}[commandchars=\\\{\}]
python -m cProfile my\_script.py
\end{Verbatim}

Note: \code{cProfile} is a faster implementation of \code{profile} as it is
written in c

\textbf{CSV to json}

Run this in the terminal:
\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{literal,string}{}
\begin{Verbatim}[commandchars=\\\{\}]
python -c "import csv,json;print json.dumps(list(csv.reader(open('csv\_file.csv'))))"
\end{Verbatim}

Make sure that you replace \code{csv\_file.csv} to the relevant file name.

\textbf{List Flattening}

You can quickly and easily flatten a list using
\code{itertools.chain.from\_iterable} from the \code{itertools} package. Here
is a simple example:
\DUspan{name}{}\DUspan{operator}{}\DUspan{punctuation}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{punctuation}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{punctuation}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{punctuation}{}\DUspan{name,builtin}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{comment}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{a\PYGZus{}list} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{]}
\PYG{k}{print}\PYG{p}{(}\PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{itertools}\PYG{o}{.}\PYG{n}{chain}\PYG{o}{.}\PYG{n}{from\PYGZus{}iterable}\PYG{p}{(}\PYG{n}{a\PYGZus{}list}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{c}{\PYGZsh{} Output: [1, 2, 3, 4, 5, 6]}
\end{Verbatim}

A couple of more one liners can be found on the \href{https://wiki.python.org/moin/Powerful\%20Python\%20One-Liners}{Python
website}


\chapter{For - Else}
\label{for_-_else:for-else}\label{for_-_else::doc}
\code{for} loops are an important feature of Python. However there are a
few things which most beginners do not know about them. We will discuss
a few of them one by one.


\section{1.\texttt{else} clause:}
\label{for_-_else:else-clause}
For loops also have an \code{else} clause which most of us are unfamiliar
with. The \code{else} clause is run when the loop completes normally. This
means that the loop did not encounter \code{break}. They are really useful
once you understand where to use them. I myself came to know about them
a lot later.

The common construct is to run a loop and search for an item. If the
item is found we break the loop using \code{break}. There are two scenarios
in which the loop may end. The first one is when the item is found and
\code{break} is encountered. The second scenario is that the loop ends. Now
we may want to know which one of these is the reason for a loops
completion. One method is to set a flag and then check it once the loop
ends. Another is to use the \code{else} clause.

This is the basic structure of a \code{for/else} loop:
\DUspan{keyword}{}\DUspan{name}{}\DUspan{operator,word}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{comment}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{keyword}{}\DUspan{punctuation}{}\DUspan{comment}{}\DUspan{name}{}\DUspan{punctuation}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{n}{item} \PYG{o+ow}{in} \PYG{n}{container}\PYG{p}{:}
    \PYG{k}{if} \PYG{n}{search\PYGZus{}comething}\PYG{p}{(}\PYG{n}{item}\PYG{p}{)}\PYG{p}{:}
        \PYG{c}{\PYGZsh{} Found it!}
        \PYG{n}{process}\PYG{p}{(}\PYG{n}{item}\PYG{p}{)}
        \PYG{k}{break}
\PYG{k}{else}\PYG{p}{:}
    \PYG{c}{\PYGZsh{} Didn\PYGZsq{}t find anything..}
    \PYG{n}{not\PYGZus{}found\PYGZus{}in\PYGZus{}container}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

Consider this simple example which I took from the official
documentation:
\DUspan{keyword}{}\DUspan{name}{}\DUspan{operator,word}{}\DUspan{name,builtin}{}\DUspan{punctuation}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{name}{}\DUspan{operator,word}{}\DUspan{name,builtin}{}\DUspan{punctuation}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{keyword}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{n}{n} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{for} \PYG{n}{x} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{if} \PYG{n}{n} \PYG{o}{\PYGZpc{}} \PYG{n}{x} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{:}
            \PYG{k}{print} \PYG{n}{n}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{equals}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{*}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{n}\PYG{o}{/}\PYG{n}{x}
            \PYG{k}{break}
\end{Verbatim}

It outputs the prime numbers between 2 to 10. Now for the fun part. We
can add an additional \code{else} block which catches the numbers which are
not prime and tells us so:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{n}{n} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{for} \PYG{n}{x} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{if} \PYG{n}{n} \PYG{o}{\PYGZpc{}} \PYG{n}{x} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{:}
            \PYG{k}{print} \PYG{n}{n}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{equals}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{*}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{n}\PYG{o}{/}\PYG{n}{x}
            \PYG{k}{break}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{c}{\PYGZsh{} loop fell through without finding a factor}
        \PYG{k}{print} \PYG{n}{n}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{is a prime number}\PYG{l+s}{\PYGZsq{}}
\end{Verbatim}


\chapter{Open function}
\label{open_function:open-function}\label{open_function::doc}
\href{http://docs.python.org/dev/library/functions.html\#open}{open} opens
a file. Pretty simple, eh? Most of the time, we see it being used like
this:
\DUspan{name}{}\DUspan{operator}{}\DUspan{name,builtin}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{f} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{photo.jpg}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{r+}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{jpgdata} \PYG{o}{=} \PYG{n}{f}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{f}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

The reason I am writing this article is that most of the time, I see
open used like this. There are \textbf{three} errors in the above code. Can
you spot them all? If not, read on. By the end of this article, you'll
know what's wrong in the above code, and, more importantly, be able to
avoid these mistakes in your own code. Let's start with the basics:

The return of open is a file handle, given out from the operating system
to your Python application. You will want to return this file handle
once you're finished with the file, if only so that your application
won't reach the limit of the number of open file handle it can have at
once.

Explicitly calling \code{close} closes the file handle, but only if the
read was successful. If there is any error just after \code{f = open(...)},
\code{f.close()} will not be called (depending on the Python interpreter,
the file handle may still be returned, but that's another story). To
make sure that the file gets closed whether an exception occurs or not,
pack it into a
\code{{}`with} \textless{}\href{http://freepythontips.wordpress.com/2013/07/28/the-with-statement/}{http://freepythontips.wordpress.com/2013/07/28/the-with-statement/}\textgreater{}{}`\_\_
statement:
\DUspan{keyword}{}\DUspan{name,builtin}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{with} \PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{photo.jpg}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{r+}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{f}\PYG{p}{:}
    \PYG{n}{jpgdata} \PYG{o}{=} \PYG{n}{f}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

The first argument of \code{open} is the filename. The second one (the
\emph{mode}) determines \emph{how} the file gets opened.
\begin{itemize}
\item {} 
If you want to read the file, pass in \code{r}

\item {} 
If you want to read and write the file, pass in \code{r+}

\item {} 
If you want to overwrite the file, pass in \code{w}

\item {} 
If you want to append to the file, pass in \code{a}

\end{itemize}

While there are a couple of other valid mode strings, chances are you
won't ever use them. The mode matters not only because it changes the
behavior, but also because it may result in permission errors. For
example, if we were to open a jpg-file in a write-protected directory,
\code{open(.., 'r+')} would fail. The mode can contain one further
character; we can open the file in binary (you'll get a string of bytes)
or text mode (a string of characters).

In general, if the format is written by humans, it tends to be text
mode. \code{jpg} image files are not generally written by humans (and are
indeed not readable to humans), and you should therefore open them in
binary mode by adding a \code{b} to the text string (if you're following
the opening example, the correct mode would be \code{rb}). If you open
something in text mode (i.e. add a \code{t}, or nothing apart from
\code{r/r+/w/a}), you must also know which encoding to use - for a
computer, all files are just bytes, not characters.

Unfortunately, \code{open} does not allow explicit encoding specification
in Python 2.x. However, the function
\code{{}`io.open} \textless{}\href{http://docs.python.org/2/library/io.html\#io.open}{http://docs.python.org/2/library/io.html\#io.open}\textgreater{}{}`\_\_ is
available in both Python 2.x and 3.x (where it is an alias of \code{open}),
and does the right thing. You can pass in the encoding with the
\code{encoding} keyword. If you don't pass in any encoding, a system- (and
Python-) specific default will be picked. You may be tempted to rely on
these defaults, but the defaults are often wrong, or the default
encoding cannot actually express all characters (this will happen on
Python 2.x and/or Windows). So go ahead and pick an encoding. \code{utf-8}
is a terrific one. When you write a file, you can just pick the encoding
to your liking (or the liking of the program that will eventually read
your file).

How do you find out which encoding a file you read has? Well,
unfortunately, there is no sureproof way to detect the encoding - the
same bytes can represent different, but equally valid characters in
different encodings. Therefore, you must rely on metadata (for example,
in HTTP headers) to know the encoding. Increasingly, formats just define
the encoding to be UTF-8.

Armed with this knowledge, let's write a program that reads a file,
determines whether it's JPG (hint: These files start with the bytes
\code{FF D8}), and writes a text file that describe the input file.
\DUspan{keyword,namespace}{}\DUspan{name,namespace}{}\DUspan{keyword}{}\DUspan{name,builtin}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{literal,string}{}\DUspan{literal,string,escape}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{literal,string}{}\DUspan{literal,string,interpol}{}\DUspan{literal,string}{}\DUspan{literal,string,escape}{}\DUspan{literal,string}{}\DUspan{keyword}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{literal,string}{}\DUspan{literal,string,interpol}{}\DUspan{literal,string}{}\DUspan{literal,string,escape}{}\DUspan{literal,string}{}\DUspan{keyword}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name,builtin}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{io}

\PYG{k}{with} \PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{photo.jpg}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{rb}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{inf}\PYG{p}{:}
    \PYG{n}{jpgdata} \PYG{o}{=} \PYG{n}{inf}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{p}{)}

\PYG{k}{if} \PYG{n}{jpgdata}\PYG{o}{.}\PYG{n}{startswith}\PYG{p}{(}\PYG{n}{b}\PYG{l+s}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}xff}\PYG{l+s+se}{\PYGZbs{}xd8}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{text} \PYG{o}{=} \PYG{l+s}{u\PYGZsq{}}\PYG{l+s}{This is a jpeg file (}\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{ bytes long)}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZsq{}}
\PYG{k}{else}\PYG{p}{:}
    \PYG{n}{text} \PYG{o}{=} \PYG{l+s}{u\PYGZsq{}}\PYG{l+s}{This is a random file (}\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s}{ bytes long)}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZsq{}}

\PYG{k}{with} \PYG{n}{io}\PYG{o}{.}\PYG{n}{open}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{summary.txt}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{w}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{encoding}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{utf\PYGZhy{}8}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{outf}\PYG{p}{:}
    \PYG{n}{outf}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{n}{text} \PYG{o}{\PYGZpc{}} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{jpgdata}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

I am sure that now you would use \code{open} correctly!


\chapter{Targeting Python 2+3}
\label{targeting_python_2_3:targeting-python-2-3}\label{targeting_python_2_3::doc}
In a lot of cases you might want to develop programs which can be run in
both, Python 2+ and 3+.

Just imagine that you have a very popular python module which is use by
hundreds of people but not all of them have python 2 or 3. In that case
you have two choices. The first one is to distribute 2 modules, one for
python 2 and the other for python 3. The other choice is to modify your
current code and make is compatible with both python 2 and 3.

In this section I am going to highlight some of the tricks which you can
employ to make a script compatible with both of them.

\textbf{Future imports}

The first and most important method is to use \code{\_\_future\_\_} imports. It
allows you to import Python 3 functionality in Python 2. Here is an
example:
\begin{itemize}
\item {} 
Context manager were new in Python 3. For using them in Python 2.5+
you can use:

\end{itemize}
\DUspan{keyword,namespace}{}\DUspan{name,namespace}{}\DUspan{keyword,namespace}{}\DUspan{name}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{\PYGZus{}\PYGZus{}future\PYGZus{}\PYGZus{}} \PYG{k+kn}{import} \PYG{n}{with\PYGZus{}statement}
\end{Verbatim}
\begin{itemize}
\item {} 
\code{print} function

\end{itemize}

\code{print} was changed to a function in Python 3. If you want to use it
in Python 2 you can import it from \code{\_\_future\_\_}.
\DUspan{keyword}{}\DUspan{comment}{}\DUspan{keyword,namespace}{}\DUspan{name,namespace}{}\DUspan{keyword,namespace}{}\DUspan{name}{}\DUspan{keyword}{}\DUspan{comment}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{print}
\PYG{c}{\PYGZsh{} Output:}

\PYG{k+kn}{from} \PYG{n+nn}{\PYGZus{}\PYGZus{}future\PYGZus{}\PYGZus{}} \PYG{k+kn}{import} \PYG{n}{print\PYGZus{}function}
\PYG{k}{print}
\PYG{c}{\PYGZsh{} Output: \PYGZlt{}built\PYGZhy{}in function print\PYGZgt{}}
\end{Verbatim}

\textbf{Using {}`{}`as{}`{}` in imports}

First tell me how you import packages in your script ? Most of us do
this :
\DUspan{keyword,namespace}{}\DUspan{name,namespace}{}\DUspan{comment}{}\DUspan{keyword,namespace}{}\DUspan{name,namespace}{}\DUspan{keyword,namespace}{}\DUspan{name}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{foo}
\PYG{c}{\PYGZsh{} or}
\PYG{k+kn}{from} \PYG{n+nn}{foo} \PYG{k+kn}{import} \PYG{n}{bar}
\end{Verbatim}

Do you know that you can do something like this as well?
\DUspan{keyword,namespace}{}\DUspan{name,namespace}{}\DUspan{keyword,namespace}{}\DUspan{name,namespace}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{foo} \PYG{k+kn}{as} \PYG{n+nn}{foo}
\end{Verbatim}

I know it’s function is the same as above listed code but it is vital
for making your script compatible with python 2 and 3. Now examine the
code below :
\DUspan{keyword}{}\DUspan{punctuation}{}\DUspan{keyword,namespace}{}\DUspan{name,namespace}{}\DUspan{keyword,namespace}{}\DUspan{name,namespace}{}\DUspan{comment}{}\DUspan{keyword}{}\DUspan{name,exception}{}\DUspan{punctuation}{}\DUspan{keyword,namespace}{}\DUspan{name,namespace}{}\DUspan{keyword,namespace}{}\DUspan{name,namespace}{}\DUspan{comment}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{try}\PYG{p}{:}
    \PYG{k+kn}{import} \PYG{n+nn}{urllib.request} \PYG{k+kn}{as} \PYG{n+nn}{urllib\PYGZus{}request} \PYG{c}{\PYGZsh{}for python 3}
\PYG{k}{except} \PYG{n+ne}{ImportError}\PYG{p}{:}
    \PYG{k+kn}{import} \PYG{n+nn}{urllib2} \PYG{k+kn}{as} \PYG{n+nn}{urllib\PYGZus{}request} \PYG{c}{\PYGZsh{} for python 2}
\end{Verbatim}

So let me explain the above code a little. We are wrapping our importing
code in a try except clause. We are doing it because in python2 there is
no urllib.request module and will result in an ImportError. The
functionality of urllib.request is provided by urllib2 module in
python2. So now when in Python2 we try to import \code{urllib.request} and
get an \code{ImportError} we tell Python to import urllib2 instead.

The final thing you need to know about is the \code{as} keyword. It is
mapping the imported module to \code{urllib\_request}. So that now all of
the Classes and methods of urllib2 are available to us by
urllib\_request.

\textbf{Obsolete Python 2 builtins}

Another thing to keep in mind is that there are 12 Python 2 builtins
which have been removed from Python 3. Make sure that you don't use them
in Python 2 as well in order to make your code compatible with Python 3.
Here is a way to enforce you to abandon these 12 builtins in Python 2 as
well.
\DUspan{keyword,namespace}{}\DUspan{name,namespace}{}\DUspan{keyword,namespace}{}\DUspan{operator}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{future.builtins.disabled} \PYG{k+kn}{import} \PYG{o}{*}
\end{Verbatim}

Now whenever you try to use the modules which are abandoned in Python 3,
it raises a NameError like this:
\DUspan{keyword,namespace}{}\DUspan{name,namespace}{}\DUspan{keyword,namespace}{}\DUspan{operator}{}\DUspan{name,builtin}{}\DUspan{punctuation}{}\DUspan{comment}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{future.builtins.disabled} \PYG{k+kn}{import} \PYG{o}{*}

\PYG{n+nb}{apply}\PYG{p}{(}\PYG{p}{)}
\PYG{c}{\PYGZsh{} Output: NameError: obsolete Python 2 builtin apply is disabled}
\end{Verbatim}

\textbf{External standard-library backports}

There are a few packages in the wild which provide Python 3
functionality in Python 2. For instance we have:
\begin{itemize}
\item {} 
enum \code{pip install enum34}

\item {} 
singledispatch \code{pip install singledispatch}

\item {} 
pathlib \code{pip install pathlib}

\end{itemize}

I am sure there are a lot of other methods and tricks which can be used
to make you code compatible with both of these Python series. This was
just to give you some ideas.


\chapter{Coroutines}
\label{coroutines:coroutines}\label{coroutines::doc}
Coroutines are similar to generators with a few differences. The main
differences are:
\begin{itemize}
\item {} 
generators are data producers

\item {} 
coroutines are data consumers

\end{itemize}

First of all let's review the generator creation process. We can make
generators like this:
\DUspan{keyword}{}\DUspan{name,function}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{literal,number,integer}{}\DUspan{keyword}{}\DUspan{name,builtin,pseudo}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{name}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{fib}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{a}\PYG{p}{,} \PYG{n}{b} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}
    \PYG{k}{while} \PYG{n+nb+bp}{True}\PYG{p}{:}
        \PYG{k}{yield} \PYG{n}{a}
        \PYG{n}{a}\PYG{p}{,} \PYG{n}{b} \PYG{o}{=} \PYG{n}{b}\PYG{p}{,} \PYG{n}{a}\PYG{o}{+}\PYG{n}{b}
\end{Verbatim}

We then commonly use it in a \code{for} loop like this:
\DUspan{keyword}{}\DUspan{name}{}\DUspan{operator,word}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{fib}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{print}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}
\end{Verbatim}

It is fast and does not put a lot of pressure on memory because it
\textbf{generates} the values on the fly rather then storing them in a list.
Now if we use \code{yield} in the above example more generally we get a
coroutine. Coroutines consume values which are sent to it. A very basic
example would be a \code{grep} alternative in Python:
\DUspan{keyword}{}\DUspan{name,function}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{literal,string}{}\DUspan{literal,string,interpol}{}\DUspan{literal,string}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{keyword}{}\DUspan{name,builtin,pseudo}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{name}{}\DUspan{operator,word}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{grep}\PYG{p}{(}\PYG{n}{pattern}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{print} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Searching for }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{n}{pattern}
    \PYG{k}{while} \PYG{n+nb+bp}{True}\PYG{p}{:}
        \PYG{n}{line} \PYG{o}{=} \PYG{p}{(}\PYG{k}{yield}\PYG{p}{)}
        \PYG{k}{if} \PYG{n}{pattern} \PYG{o+ow}{in} \PYG{n}{line}\PYG{p}{:}
            \PYG{k}{print}\PYG{p}{(}\PYG{n}{line}\PYG{p}{)}
\end{Verbatim}

Wait! What does \code{yield} return? Well we have turned it into a
coroutine. It does not contain any value innitially instead we supply it
values externally. We supply values by using the \code{.send()} method.
Here is an example:
\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{comment}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{comment}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{search} \PYG{o}{=} \PYG{n}{grep}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{coroutine}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{search}\PYG{o}{.}\PYG{n}{next}\PYG{p}{(}\PYG{p}{)}
\PYG{c}{\PYGZsh{} Output: Searching for coroutine}
\PYG{n}{search}\PYG{o}{.}\PYG{n}{send}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{I love you}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{search}\PYG{o}{.}\PYG{n}{send}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Don}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{t you love me?}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{search}\PYG{o}{.}\PYG{n}{send}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{I love coroutines instead!}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}
\PYG{c}{\PYGZsh{} Output: I love coroutines instead!}
\end{Verbatim}

The sent values are accessed by yield. Why did we run \code{.next()}? It is
done to start the coroutine. Just like \code{generators} coroutines do not
start the function immediately. Instead they run it in response to
\code{.next()} and \code{.send()} methods. Therefore you have to run
\code{.next()} so that the execution advances to the \code{yield} expression.

We can close a coroutine by calling the \code{.close()} method. Like:
\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{literal,string}{}\DUspan{punctuation}{}\DUspan{comment}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{search} \PYG{o}{=} \PYG{n}{grep}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{coroutine}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{c}{\PYGZsh{} ...}
\PYG{n}{search}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

There is a lot more to \code{coroutines}. I suggest you check out \href{http://www.dabeaz.com/coroutines/Coroutines.pdf}{this
awesome
presentation} by
David Beazley.


\chapter{Function caching}
\label{function_caching:function-caching}\label{function_caching::doc}
Function caching allows us to cache the return values of a function
depending on the arguments. It can save time when an I/O bound function
is periodically called with the same arguments. Before Python 3.2 we had
to write a custom implementation. In Python 3.2+ there is an
\code{lru\_cache} decorator which allows us to quickly cache and uncache the
return values of a function.

Let's see how we can use it in Python 3.2+ and the versions before it.


\section{Python 3.2+}
\label{function_caching:python-3-2}
Let's implement a ficonnaci calculator and use \code{lru\_cache}.
\DUspan{keyword,namespace}{}\DUspan{name,namespace}{}\DUspan{keyword,namespace}{}\DUspan{name}{}\DUspan{name,decorator}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{name,function}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{name}{}\DUspan{keyword}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{operator}{}\DUspan{keyword}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{name}{}\DUspan{operator,word}{}\DUspan{name,builtin}{}\DUspan{punctuation}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{comment}{}
\begin{Verbatim}[commandchars=\\\{\}]
from functools import lru\_cache

@lru\_cache(maxsize=32)
def fib(n):
    if n \textless{} 2:
        return n
    return fib(n-1) + fib(n-2)

\textgreater{}\textgreater{}\textgreater{} print([fib(n) for n in range(10)])
\# Output: [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]
\end{Verbatim}

The \code{maxsize} argument tells \code{lru\_cache} about how many recent
return values to cache.

We can easily uncache the return values as well by using:
\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{fib}\PYG{o}{.}\PYG{n}{cache\PYGZus{}clear}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}


\section{Python 2+}
\label{function_caching:python-2}
There are a couple of ways to achieve the same effect. You can create
any type of caching machanism. It entirely depends upon your needs. Here
is a generic cache:
\DUspan{keyword,namespace}{}\DUspan{name,namespace}{}\DUspan{keyword,namespace}{}\DUspan{name}{}\DUspan{keyword}{}\DUspan{name,function}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{punctuation}{}\DUspan{name,decorator}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{name,function}{}\DUspan{punctuation}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{name}{}\DUspan{operator,word}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{keyword}{}\DUspan{name}{}\DUspan{keyword}{}\DUspan{name}{}\DUspan{name,decorator}{}\DUspan{keyword}{}\DUspan{name,function}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{keyword}{}\DUspan{name}{}\DUspan{keyword}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{operator}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{operator}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}\DUspan{name}{}\DUspan{punctuation}{}\DUspan{literal,number,integer}{}\DUspan{punctuation}{}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{functools} \PYG{k+kn}{import} \PYG{n}{wraps}

\PYG{k}{def} \PYG{n+nf}{memoize}\PYG{p}{(}\PYG{n}{function}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{memo} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
    \PYG{n+nd}{@wraps}\PYG{p}{(}\PYG{n}{function}\PYG{p}{)}
    \PYG{k}{def} \PYG{n+nf}{wrapper}\PYG{p}{(}\PYG{o}{*}\PYG{n}{args}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{if} \PYG{n}{args} \PYG{o+ow}{in} \PYG{n}{memo}\PYG{p}{:}
            \PYG{k}{return} \PYG{n}{memo}\PYG{p}{[}\PYG{n}{args}\PYG{p}{]}
        \PYG{k}{else}\PYG{p}{:}
            \PYG{n}{rv} \PYG{o}{=} \PYG{n}{function}\PYG{p}{(}\PYG{o}{*}\PYG{n}{args}\PYG{p}{)}
            \PYG{n}{memo}\PYG{p}{[}\PYG{n}{args}\PYG{p}{]} \PYG{o}{=} \PYG{n}{rv}
            \PYG{k}{return} \PYG{n}{rv}
    \PYG{k}{return} \PYG{n}{wrapper}

\PYG{n+nd}{@memoize}
\PYG{k}{def} \PYG{n+nf}{fibonacci}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{if} \PYG{n}{n} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{2}\PYG{p}{:} \PYG{k}{return} \PYG{n}{n}
    \PYG{k}{return} \PYG{n}{fibonacci}\PYG{p}{(}\PYG{n}{n} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{+} \PYG{n}{fibonacci}\PYG{p}{(}\PYG{n}{n} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{2}\PYG{p}{)}

\PYG{n}{fibonacci}\PYG{p}{(}\PYG{l+m+mi}{25}\PYG{p}{)}
\end{Verbatim}



\renewcommand{\indexname}{Index}
\printindex
\end{document}
